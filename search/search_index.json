{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>virtualtools<ul> <li>generators<ul> <li>tpgenerator</li> <li>vtgenerator</li> </ul> </li> <li>helpers<ul> <li>geom</li> <li>misc</li> <li>physics</li> <li>pmhelp</li> </ul> </li> <li>interfaces<ul> <li>gameTypes</li> <li>oneball</li> <li>phyre_actions</li> <li>running</li> <li>simpledropper</li> <li>toolpicker</li> <li>vertexdrawer</li> <li>vtinterface</li> </ul> </li> <li>vtviewer<ul> <li>interfaces</li> <li>movies</li> <li>visualization</li> <li>visualize_likelihoods</li> </ul> </li> <li>world<ul> <li>abstracts</li> <li>conditions</li> <li>constants</li> <li>noisyworld</li> <li>object</li> <li>world</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/virtualtools/","title":"virtualtools","text":""},{"location":"reference/virtualtools/#virtualtools.VTWorld","title":"<code>VTWorld</code>","text":"<p>             Bases: <code>object</code></p> Source code in <code>virtualtools/world/world.py</code> <pre><code>class VTWorld(object):\n\n    def __init__(self,\n                 dimensions: Tuple[float, float],\n                 gravity: float,\n                 closed_ends: Annotated[Tuple[bool], 4] = [True,True,True,True],\n                 basic_timestep: float = 0.01,\n                 def_density: float = DEFAULT_DENSITY,\n                 def_elasticity: float = DEFAULT_ELASTICITY,\n                 def_friction: float = DEFAULT_FRICTION,\n                 bk_col: Annotated[Tuple[int], 3] = (255,255,255),\n                 def_col: Annotated[Tuple[int], 3] = (0,0,0)):\n        \"\"\"Instantiates a virtual tools world\n\n        Args:\n            dimensions (Tuple[float, float]): the (x,y) limits of the world\n            gravity (float): the strength of gravity pointing down in units/s^2\n            closed_ends (Annotated[Tuple[bool], 4], optional): a set of flags to say whether a [left, bottom, right, top] wall should be added around the world. Defaults to [True,True,True,True].\n            basic_timestep (float, optional): the amount of time to step forward when calculatign physics. Smaller values will slow down the simulation but be more precise. Larger values might cause \"tunneling\" or other physics instabilities. Defaults to 0.01.\n            def_density (float, optional): the default density of all objects in the world, unless otherwise specified. Defaults to 1.\n            def_elasticity (float, optional): the default elasticity of all objects in the world, unless otherwise specified. Defaults to 0.5.\n            def_friction (float, optional): _description_. the default friction of all objects in the world, unless otherwise specified. Defaults to 0.5.\n            bk_col (Annotated[Tuple[int], 3], optional): the RGB value of the background of the tools world. Defaults to white (255,255,255).\n            def_col (Annotated[Tuple[int], 3], optional): the default RGB color of objects added to the world. Not guaranteed to catch. Defaults to black (0,0,0).\n        \"\"\"        \n\n        self.def_density = def_density\n        self.def_elasticity = def_elasticity\n        self.def_friction = def_friction\n        self.bk_col = bk_col\n        self.def_col = def_col\n\n        self.dims = dimensions\n        self.bts = basic_timestep\n        self.time = 0\n        self.has_place_collision = False\n\n        self._cpSpace = pm.Space()\n        self._cpSpace.gravity = (0, -gravity)\n        self._cpSpace.sleep_time_threshold = 5.\n\n        self.objects = dict()\n        self.blockers = dict()\n        self.constraints = dict() # Not implemented yet\n\n        self.goal_cond = None\n        self.win_callback = None\n        self._collision_events = []\n        self._ssBegin = _empty_collision_handler\n        self._ssPre = _empty_collision_handler\n        self._ssPost = _empty_collision_handler\n        self._ssEnd = _empty_collision_handler\n        self._sgBegin = _empty_collision_handler\n        self._sgEnd = _empty_collision_handler\n\n        def do_solid_solid_begin(arb, space, data):\n            return self._solid_solid_begin(arb, space, data)\n        def do_solid_solid_pre(arb, space, data):\n            return self._solid_solid_pre(arb, space, data)\n        def do_solid_solid_post(arb, space, data):\n            return self._solid_solid_post(arb, space, data)\n        def do_solid_solid_end(arb, space, data):\n            return self._solid_solid_end(arb, space, data)\n        def do_solid_goal_begin(arb, space, data):\n            return self._solid_goal_begin(arb, space, data)\n        def do_solid_goal_end(arb, space, data):\n            return self._solid_goal_end(arb, space, data)\n\n        ssch = self._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SOLID)\n        ssch.begin = do_solid_solid_begin\n        ssch.pre_solve = do_solid_solid_pre\n        ssch.post_solve = do_solid_solid_post\n        ssch.separate = do_solid_solid_end\n\n        psch = self._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SOLID)\n        psch.begin = do_solid_solid_begin\n        psch.pre_solve = do_solid_solid_pre\n        psch.post_solve = do_solid_solid_post\n        psch.separate = do_solid_solid_end\n\n        ssench = self._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SENSOR)\n        ssench.begin = do_solid_goal_begin\n        ssench.separate = do_solid_goal_end\n\n        psench = self._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SENSOR)\n        psench.begin = do_solid_goal_begin\n        psench.separate = do_solid_goal_end\n\n        if closed_ends[0]:\n            self.add_box(\"_LeftWall\",[-1,-1,1,self.dims[1]+1], self.def_col, 0)\n        if closed_ends[1]:\n            self.add_box(\"_BottomWall\", [-1,-1,self.dims[0]+1, 1], self.def_col, 0);\n        if closed_ends[2]:\n            self.add_box(\"_RightWall\", [self.dims[0] - 1, -1, self.dims[0] + 1, self.dims[1] + 1], self.def_col, 0);\n        if closed_ends[3]:\n            self.add_box(\"_TopWall\", [-1, self.dims[1] - 1, self.dims[0] + 1, self.dims[1] + 1], self.def_col, 0);\n\n    def step(self, t: float):\n        \"\"\"Steps the world forward by t seconds. Not that this will not affect the precision of physics simulation; that is done via the `basic_timestep` value upon initialization\n\n        Args:\n            t (float): the amount of time (in seconds) to step forward\n        \"\"\"        \n        nsteps = int(np.floor(t / self.bts))\n        remtime = self.bts % t\n        self.time += t\n        for i in range(nsteps):\n            self._cpSpace.step(self.bts)\n            if self.check_end() and self.win_callback is not None:\n                self.win_callback()\n        if remtime / self.bts &gt; .01:\n            self._cpSpace.step(remtime)\n        if self.check_end() and self.win_callback is not None:\n            self.win_callback()\n\n    def _invert(self, pt):\n        return (pt[0], self.dims[1] - pt[1])\n\n    def _yinvert(self, y):\n        return self.dims[1] - y\n\n    def check_end(self) -&gt; bool:\n        \"\"\"Returns whether the victory condition of the world has been cleared\n\n        Returns:\n            bool: true if victory is achieved; false if not (or if no condition exists)\n        \"\"\"        \n        if self.goal_cond is None:\n            return False\n        return self.goal_cond.is_won()\n\n    def get_object(self, name: str) -&gt; VTObject:\n        \"\"\"Returns an object that exists in the world\n\n        Args:\n            name (str): the Virtual Tools name flag of the object\n\n        Returns:\n            VTObject: the object within the world\n\n        Raises:\n            AssertionError: if the object doesn't exist\n        \"\"\"        \n        assert name in self.objects.keys(), \"No object by that name: \" + name\n        return self.objects[name]\n\n    def get_gravity(self) -&gt; float:\n        \"\"\"Returns the gravity in units/s^2 downwards\n\n        Returns:\n            float: gravity\n        \"\"\"        \n        return -self._cpSpace.gravity.y\n\n    def set_gravity(self, val: float):\n        \"\"\"Sets the gravity in units/s^2 downwards. Negative values make things fall \"up\"\n\n        Args:\n            val (float): gravity\n        \"\"\"        \n        self._cpSpace.gravity = (0, -val)\n\n    ########################################\n    # Adding things to the world\n    ########################################\n    def add_poly(self,\n                 name, vertices, color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        this_obj = VTPoly(name, self._cpSpace, vertices, density, elasticity, friction, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_box(self, name, bounds, color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        assert len(bounds) == 4, \"Need four numbers for bounds [l,b,r,t]\"\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        l = bounds[0]\n        b = bounds[1]\n        r = bounds[2]\n        t = bounds[3]\n        vertices = [(l,b), (l,t), (r,t), (r,b)]\n\n        this_obj = VTPoly(name, self._cpSpace, vertices, density, elasticity, friction, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_ball(self, name, position, radius, color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        this_obj = VTBall(name, self._cpSpace, position, radius, density, elasticity, friction, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_segment(self, name, p1, p2, width, color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        this_obj = VTSeg(name, self._cpSpace, p1, p2, width, density, elasticity, friction, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_container(self, name, ptlist, width, inner_color, outer_color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        this_obj = VTContainer(name, self._cpSpace, ptlist, width, density, elasticity, friction, inner_color, outer_color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_compound(self, name, polys, color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        this_obj = VTCompound(name, self._cpSpace, polys, density, elasticity, friction, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_poly_goal(self, name, vertices, color):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        this_obj = VTGoal(name, self._cpSpace, vertices, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_box_goal(self, name, bounds, color):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        assert len(bounds) == 4, \"Need four numbers for bounds [l,b,r,t]\"\n        l = bounds[0]\n        b = bounds[1]\n        r = bounds[2]\n        t = bounds[3]\n        vertices = [(l, b), (l, t), (r, t), (r, b)]\n        this_obj = VTGoal(name, self._cpSpace, vertices, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_placed_poly(self, name, vertices, color, density = None, elasticity = None, friction = None):\n        this_obj = self.add_poly(name, vertices, color, density, elasticity, friction)\n        this_obj._cpShape.collision_type = COLTYPE_PLACED\n        return this_obj\n\n    def add_placed_compound(self, name, polys, color, density = None, elasticity = None, friction = None):\n        this_obj = self.add_compound(name, polys, color, density, elasticity, friction)\n        for cpsh in this_obj._cpShapes:\n            cpsh.collision_type = COLTYPE_PLACED\n        return this_obj\n\n    def add_placed_circle(self, name, position, radius, color, density=None, elasticity=None, friction=None):\n        this_obj = self.add_ball(name, position, radius, color, density, elasticity, friction)\n        this_obj._cpShape.collision_type = COLTYPE_PLACED\n        return this_obj\n\n    def add_block(self, name, bounds, color):\n        assert name not in self.blockers.keys(), \"Name already taken: \" + name\n        assert len(bounds) == 4, \"Need four numbers for bounds [l,b,r,t]\"\n        l = bounds[0]\n        b = bounds[1]\n        r = bounds[2]\n        t = bounds[3]\n        vertices = [(l, b), (l, t), (r, t), (r, b)]\n        this_obj = VTBlocker(name, self._cpSpace, vertices, color)\n        self.blockers[name] = this_obj\n        return this_obj\n\n    def add_poly_block(self, name, vertices, color):\n        assert name not in self.blockers.keys(), \"Name already taken: \" + name\n        this_obj = VTBlocker(name, self._cpSpace, vertices, color)\n        self.blockers[name] = this_obj\n        return this_obj\n\n    ########################################\n    # Callbacks\n    ########################################\n    def get_solid_collision_pre(self) -&gt; Callable:\n        return self._ssPre\n\n    def set_solid_collision_pre(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._ssPre = fnc\n\n    def get_solid_collision_post(self) -&gt; Callable:\n        return self._ssPost\n\n    def set_solid_collision_post(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._ssPost = fnc\n\n    def get_solid_collision_begin(self) -&gt; Callable:\n        return self._ssBegin\n\n    def set_solid_collision_begin(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._ssBegin = fnc\n\n    def get_solid_collision_end(self) -&gt; Callable:\n        return self._ssEnd\n\n    def set_solid_collision_end(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._ssEnd = fnc\n\n    def get_goal_collision_begin(self) -&gt; Callable:\n        return self._sgBegin\n\n    def set_goal_collision_begin(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._sgBegin = fnc\n\n    def get_goal_collision_end(self) -&gt; Callable:\n        return self._sgEnd\n\n    def set_goal_collision_end(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._sgEnd = fnc\n\n    def _solid_solid_pre(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        self._ssPre(o1,o2)\n        return True\n\n    def _solid_solid_post(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        self._ssPost(o1, o2)\n        return True\n\n    def _solid_solid_begin(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        # Add any non-static/static collisions to the events\n        if not (o1.is_static() and o2.is_static()):\n            collision_info = pull_collision_information(arb)\n            self._collision_events.append([onms[0],onms[1], \"begin\",self.time, collision_info])\n        self._ssBegin(o1, o2)\n        return True\n\n    def _solid_solid_end(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        # Add any non-static/static collisions to the events\n        if not (o1.is_static() and o2.is_static()):\n            collision_info = pull_collision_information(arb)\n            self._collision_events.append([onms[0], onms[1], \"end\", self.time, collision_info])\n        self._ssEnd(o1, o2)\n        return True\n\n    def _solid_goal_begin(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        self._sgBegin(o1, o2)\n        return True\n\n    def _solid_goal_end(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        self._sgEnd(o1, o2)\n        return True\n\n    ########################################\n    # Victory conditions\n    ########################################\n    def _get_callback_on_win(self):\n        return self.win_callback\n\n    def _set_callback_on_win(self, fnc):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self.win_callback = fnc\n\n    def attach_any_in_goal(self, goalname: str, duration: float, exclusions: List[str] = []):\n        \"\"\"Sets a victory condition in which any object can make it into the goal area (except those specified in exclusions)\n\n        Args:\n            goalname (str): the Virtual Tools name of the goal object\n            duration (float): the amount of time (in seconds) an object must remain in the goal\n            exclusions (List[str], optional): a list of Virtual Tools names of objects that will *not* trigger victory. Defaults to [].\n        \"\"\"        \n        self.goal_cond = VTCond_AnyInGoal(goalname, duration, self, exclusions)\n        self.goal_cond.attach_hooks()\n\n    def attach_specific_in_goal(self, goalname: str, objname: str, duration: float):\n        \"\"\"Sets a victory condition in which a specific object must make it into a specific goal area\n\n        Args:\n            goalname (str): the Virtual Tools name of the goal object\n            objname (str): the Virtual Tools name of the target object to go into the goal\n            duration (float): the amount of time (in seconds) an object must remain in the goal\n        \"\"\"        \n        self.goal_cond = VTCond_SpecificInGoal(goalname, objname, duration, self)\n        self.goal_cond.attach_hooks()\n\n    def attach_many_in_goal(self, goalname: str, objlist: List[str], duration: float):\n        \"\"\"Sets a victory condition in which any of a set of objects must make it into a specific goal area\n\n        Args:\n            goalname (str): the Virtual Tools name of the goal object\n            objlist (List[str]): a list of Virtual Tools names of objects to go into the goal\n            duration (float): the amount of time (in seconds) an object must remain in the goal\n        \"\"\"        \n        self.goal_cond = VTCond_ManyInGoal(goalname, objlist, duration, self)\n        self.goal_cond.attach_hooks()\n\n    def attach_any_touch(self, objname: str, duration: float):\n        \"\"\"Sets a victory condition in which any dynamic object must touch a specific object\n\n        Args:\n            objname (str): the Virtual Tools name of the target object to be touched\n            duration (float): the amount of time (in seconds) the objects must remain in contact\n        \"\"\"        \n        self.goal_cond = VTCond_AnyTouch(objname, duration, self)\n        self.goal_cond.attach_hooks()\n\n    def attach_specific_touch(self, obj1: str, obj2: str, duration: float):\n        \"\"\"Sets a victory condition in which two objects must come into contact\n\n        Args:\n            obj1 (str): the Virtual Tools name of one of the target objects\n            obj2 (str): the Virtual Tools name of the other target object\n            duration (float): the amount of time (in seconds) the objects must remain in contact\n        \"\"\"        \n        self.goal_cond = VTCond_SpecificTouch(obj1, obj2, duration, self)\n        self.goal_cond.attach_hooks()\n\n    def check_finishers(self) -&gt; bool:\n        \"\"\"Makes sure there is a way to exit the world -- a victory condition and a win_callback that happens afterwards\n\n        Returns:\n            bool: true if goal_cond and win_callback exist, false otherwise\n        \"\"\"        \n        return self.goal_cond is not None and self.win_callback is not None\n\n    ########################################\n    # Checking collisions\n    ########################################\n\n    def reset_collisions(self):\n        \"\"\"Clears out the collision events list\n        \"\"\"        \n        self._collision_events = []\n\n    def _get_collision_events(self):\n        return self._collision_events\n\n    ########################################\n    # Misc\n    ########################################\n    def check_collision(self, pos: Tuple[float, float], verts: List[Tuple[float, float]]) -&gt; bool:\n        \"\"\"Checks whether placing a convex polygon in the world would cause a collision\n\n        Args:\n            pos (Tuple[float, float]): the position of the hypothetical polygon (where all vertices are calculated wrt)\n            verts (List[Tuple[float, float]]): a list of (x,y) vertices of the convex polygon, relative to the position\n\n        Returns:\n            bool: true if there would be a collision, false if not\n        \"\"\"        \n        nvert = [(v[0]+pos[0], v[1]+pos[1]) for v in verts]\n        tmpBody = pm.Body(1,1)\n        placeShape = pm.Poly(tmpBody, nvert)\n        placeShape.collision_type = COLTYPE_CHECKER\n        placeShape.sensor = True\n        self._cpSpace.step(.000001)\n\n        self.has_place_collision = False\n        squery = self._cpSpace.shape_query(placeShape)\n        \"\"\" Code doesn't account for blockers (sensors)\n        # Update 12/12/23: I don't see why this wouldn't but if you're getting incorrect output, check the blockers!\n        if len(squery) == 0:\n            return False\n        else:\n            for sq in squery:\n                for p in sq.contact_point_set.points:\n                    if p.distance &gt; 0:\n                        return True\n            return False\n        \"\"\"\n        return len(squery) &gt; 0\n\n    def check_circle_collision(self, pos: Tuple[float, float], rad: float) -&gt; bool:\n        \"\"\"Checks if there would be a colision with an object if a circular object were placed in the world\n\n        Args:\n            pos (Tuple[float, float]): the center of the hypothetical circular object\n            rad (float): the radius of the hypothetical circular object\n\n        Returns:\n            bool: true if there would be a colision, false if not\n        \"\"\"        \n        tmpBody = pm.Body(1,1)\n        placeShape = pm.Circle(tmpBody, rad, pos)\n        placeShape.collision_type = COLTYPE_CHECKER\n        placeShape.sensor = True\n        self._cpSpace.step(.000001)\n\n        self.has_place_collision = False\n        squery = self._cpSpace.shape_query(placeShape)\n        return len(squery) &gt; 0\n\n    def kick(self, objectname: str, impulse: Tuple[float, float], position: Tuple[float, float]):\n        \"\"\"Applies an impulse to an object at a particular point\n\n        Args:\n            objectname (str): the Virtual Tools name of the object in this world\n            impulse (Tuple[float, float]): the impulse (momentum) vector\n            position (Tuple[float, float]): the point to apply the impulse to in world coordinates. Note: this must be inside the object!\n        \"\"\"        \n        o = self.get_object(objectname)\n        o.kick(impulse, position)\n\n    def distance_to_goal(self, point: Tuple[float, float]) -&gt; float:\n        \"\"\"Returns the distance between the nearest object achieving victory and the goal area / other object\n\n        WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!\n\n        Args:\n            point (Tuple[float, float]): _description_\n\n        Returns:\n            float: _description_\n\n        Raises:\n            AssertionError: if no goal condition is specified\n        \"\"\"        \n        assert self.goal_cond, \"Goal condition must be specified to get distance\"\n        warnings.warn(\"This function is old and looks wrong - be careful using it\")\n        # Special case... requires getting two distances\n        if type(self.goal_cond) == VTCond_SpecificTouch:\n            o1 = self.get_object(self.goal_cond.o1)\n            o2 = self.get_object(self.goal_cond.o2)\n            #in this case, we actually want the distance between these two objects...\n            return np.abs(o1.distance_from_point([0,0]) - o2.distance_from_point([0,0])) #distance between these two objects is thing that matters\n        else:\n            gobj = self.get_object(self.goal_cond.goal)\n            return max(gobj.distance_from_point(point), 0)\n\n    def distance_to_goal_container(self, point: Tuple[float, float]):\n        \"\"\"Returns the distance between the nearest object achieving victory and the goal area / other object; specifies that for container objects, you want the distance to the top of the container\n\n        WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!\n\n\n        Args:\n            point (Tuple[float, float]): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        assert self.goal_cond, \"Goal condition must be specified to get distance\"\n        warnings.warn(\"This function is old and looks wrong - be careful using it\")\n        try:\n            # Special case... requires getting two distances\n            if type(self.goal_cond) == VTCond_SpecificTouch:\n                o1 = self.get_object(self.goal_cond.o1)\n                o2 = self.get_object(self.goal_cond.o2)\n                #in this case, we actually want the distance between these two objects...\n                return np.abs(o1.distance_from_point([0,0]) - o2.distance_from_point([0,0])) #distance between these two objects is thing that matters\n            else:\n                gobj = self.get_object(self.goal_cond.goal)\n                if gobj.type != 'Container':\n                    return gobj.distance_from_point(point)\n                else:\n                    if self.distance_to_goal(point) == 0:\n                        return 0\n                    else:\n                        return distance_to_object(gobj, point)\n        except:\n            pdb.set_trace()\n\n    def get_dynamic_objects(self) -&gt; List[VTObject]:\n        \"\"\"Returns a list of all dynamic (not static) objects in the world\n\n        Returns:\n            List[VTObject]: a List of all of the dynamics VTObjects\n        \"\"\"        \n        return [self.objects[i] for i in self.objects.keys() if not self.objects[i].is_static()]\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"Outputs a JSON-serializable Dict describing the world\n\n        Raises:\n            Exception: if invalid object or goal types exist in the world. In theory this should never happen\n\n        Returns:\n            Dict: a JSON-serializable Dict\n        \"\"\"        \n        wdict = dict()\n        wdict['dims'] = tuple(self.dims)\n        wdict['bts'] = self.bts\n        wdict['gravity'] = self.gravity\n        wdict['defaults'] = dict(density=self.def_density, friction=self.def_friction,\n                                 elasticity=self.def_elasticity, color=self.def_col, bk_color=self.bk_col)\n\n        wdict['objects'] = dict()\n        for nm, o in self.objects.items():\n            attrs = dict(type=o.type, color=list(o.color), density=o.density,\n                         friction=o.friction, elasticity=o.elasticity)\n            if o.type == 'Poly':\n                attrs['vertices'] = _listify(o.vertices)\n            elif o.type == 'Ball':\n                attrs['position'] = list(o.position)\n                attrs['radius'] = o.radius\n            elif o.type == 'Segment':\n                attrs['p1'], attrs['p2'] = _listify(o.points)\n                attrs['width'] = o.r * 2\n            elif o.type == 'Container':\n                attrs['points'] = _listify(o.vertices)\n                attrs['width'] = o.r * 2\n                attrs['innerColor'] = o.inner_color\n                attrs['outerColor'] = o.outer_color\n            elif o.type == 'Goal':\n                attrs['vertices'] = _listify(o.vertices)\n            elif o.type == 'Compound':\n                attrs['polys'] = _listify(o.polys)\n            else:\n                raise Exception('Invalid object type provided')\n            wdict['objects'][nm] = attrs\n\n        wdict['blocks'] = dict()\n        for nm, b in self.blockers.items():\n            attrs = {'color': list(b.color), 'vertices': _listify(b.vertices)}\n            wdict['blocks'][nm] = attrs\n\n        wdict['constraints'] = dict()\n\n        if self.goal_cond is None:\n            wdict['gcond'] = None\n        else:\n            gc = self.goal_cond\n            if gc.type == 'AnyInGoal':\n                wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': '-',\n                                  'exclusions': gc.excl, 'duration': gc.dur}\n            elif gc.type == 'SpecificInGoal':\n                wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': gc.obj, 'duration': gc.dur}\n            elif gc.type == 'ManyInGoal':\n                wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'objlist': gc.objlist, 'duration': gc.dur}\n            elif gc.type == \"AnyTouch\":\n                wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': '-', 'duration': gc.dur}\n            elif gc.type == 'SpecificTouch':\n                wdict['gcond'] = {'type': gc.type, 'goal': gc.o1, 'obj': gc.o2, 'duration': gc.dur}\n            else:\n                raise Exception('Invalid goal condition type provided')\n\n        return wdict\n\n    def copy(self):\n        return load_vt_from_dict(self.to_dict())\n\n    ########################################\n    # Properties\n    ########################################\n    gravity = property(get_gravity, set_gravity)\n    solid_collision_pre = property(get_solid_collision_pre,\n                                    set_solid_collision_pre)\n    solid_collision_post = property(get_solid_collision_post,\n                                     set_solid_collision_post)\n    solid_collision_begin = property(get_solid_collision_begin,\n                                    set_solid_collision_begin)\n    solid_collision_end = property(get_solid_collision_end,\n                                  set_solid_collision_end)\n    goal_collision_begin = property(get_goal_collision_begin,\n                                   set_goal_collision_begin)\n    goal_collision_end = property(get_goal_collision_end,\n                                 set_goal_collision_end)\n    callback_on_win = property(_get_callback_on_win, _set_callback_on_win)\n    collision_events = property(_get_collision_events)\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.__init__","title":"<code>__init__(dimensions, gravity, closed_ends=[True, True, True, True], basic_timestep=0.01, def_density=DEFAULT_DENSITY, def_elasticity=DEFAULT_ELASTICITY, def_friction=DEFAULT_FRICTION, bk_col=(255, 255, 255), def_col=(0, 0, 0))</code>","text":"<p>Instantiates a virtual tools world</p> <p>Parameters:</p> Name Type Description Default <code>dimensions</code> <code>Tuple[float, float]</code> <p>the (x,y) limits of the world</p> required <code>gravity</code> <code>float</code> <p>the strength of gravity pointing down in units/s^2</p> required <code>closed_ends</code> <code>Annotated[Tuple[bool], 4]</code> <p>a set of flags to say whether a [left, bottom, right, top] wall should be added around the world. Defaults to [True,True,True,True].</p> <code>[True, True, True, True]</code> <code>basic_timestep</code> <code>float</code> <p>the amount of time to step forward when calculatign physics. Smaller values will slow down the simulation but be more precise. Larger values might cause \"tunneling\" or other physics instabilities. Defaults to 0.01.</p> <code>0.01</code> <code>def_density</code> <code>float</code> <p>the default density of all objects in the world, unless otherwise specified. Defaults to 1.</p> <code>DEFAULT_DENSITY</code> <code>def_elasticity</code> <code>float</code> <p>the default elasticity of all objects in the world, unless otherwise specified. Defaults to 0.5.</p> <code>DEFAULT_ELASTICITY</code> <code>def_friction</code> <code>float</code> <p>description. the default friction of all objects in the world, unless otherwise specified. Defaults to 0.5.</p> <code>DEFAULT_FRICTION</code> <code>bk_col</code> <code>Annotated[Tuple[int], 3]</code> <p>the RGB value of the background of the tools world. Defaults to white (255,255,255).</p> <code>(255, 255, 255)</code> <code>def_col</code> <code>Annotated[Tuple[int], 3]</code> <p>the default RGB color of objects added to the world. Not guaranteed to catch. Defaults to black (0,0,0).</p> <code>(0, 0, 0)</code> Source code in <code>virtualtools/world/world.py</code> <pre><code>def __init__(self,\n             dimensions: Tuple[float, float],\n             gravity: float,\n             closed_ends: Annotated[Tuple[bool], 4] = [True,True,True,True],\n             basic_timestep: float = 0.01,\n             def_density: float = DEFAULT_DENSITY,\n             def_elasticity: float = DEFAULT_ELASTICITY,\n             def_friction: float = DEFAULT_FRICTION,\n             bk_col: Annotated[Tuple[int], 3] = (255,255,255),\n             def_col: Annotated[Tuple[int], 3] = (0,0,0)):\n    \"\"\"Instantiates a virtual tools world\n\n    Args:\n        dimensions (Tuple[float, float]): the (x,y) limits of the world\n        gravity (float): the strength of gravity pointing down in units/s^2\n        closed_ends (Annotated[Tuple[bool], 4], optional): a set of flags to say whether a [left, bottom, right, top] wall should be added around the world. Defaults to [True,True,True,True].\n        basic_timestep (float, optional): the amount of time to step forward when calculatign physics. Smaller values will slow down the simulation but be more precise. Larger values might cause \"tunneling\" or other physics instabilities. Defaults to 0.01.\n        def_density (float, optional): the default density of all objects in the world, unless otherwise specified. Defaults to 1.\n        def_elasticity (float, optional): the default elasticity of all objects in the world, unless otherwise specified. Defaults to 0.5.\n        def_friction (float, optional): _description_. the default friction of all objects in the world, unless otherwise specified. Defaults to 0.5.\n        bk_col (Annotated[Tuple[int], 3], optional): the RGB value of the background of the tools world. Defaults to white (255,255,255).\n        def_col (Annotated[Tuple[int], 3], optional): the default RGB color of objects added to the world. Not guaranteed to catch. Defaults to black (0,0,0).\n    \"\"\"        \n\n    self.def_density = def_density\n    self.def_elasticity = def_elasticity\n    self.def_friction = def_friction\n    self.bk_col = bk_col\n    self.def_col = def_col\n\n    self.dims = dimensions\n    self.bts = basic_timestep\n    self.time = 0\n    self.has_place_collision = False\n\n    self._cpSpace = pm.Space()\n    self._cpSpace.gravity = (0, -gravity)\n    self._cpSpace.sleep_time_threshold = 5.\n\n    self.objects = dict()\n    self.blockers = dict()\n    self.constraints = dict() # Not implemented yet\n\n    self.goal_cond = None\n    self.win_callback = None\n    self._collision_events = []\n    self._ssBegin = _empty_collision_handler\n    self._ssPre = _empty_collision_handler\n    self._ssPost = _empty_collision_handler\n    self._ssEnd = _empty_collision_handler\n    self._sgBegin = _empty_collision_handler\n    self._sgEnd = _empty_collision_handler\n\n    def do_solid_solid_begin(arb, space, data):\n        return self._solid_solid_begin(arb, space, data)\n    def do_solid_solid_pre(arb, space, data):\n        return self._solid_solid_pre(arb, space, data)\n    def do_solid_solid_post(arb, space, data):\n        return self._solid_solid_post(arb, space, data)\n    def do_solid_solid_end(arb, space, data):\n        return self._solid_solid_end(arb, space, data)\n    def do_solid_goal_begin(arb, space, data):\n        return self._solid_goal_begin(arb, space, data)\n    def do_solid_goal_end(arb, space, data):\n        return self._solid_goal_end(arb, space, data)\n\n    ssch = self._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SOLID)\n    ssch.begin = do_solid_solid_begin\n    ssch.pre_solve = do_solid_solid_pre\n    ssch.post_solve = do_solid_solid_post\n    ssch.separate = do_solid_solid_end\n\n    psch = self._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SOLID)\n    psch.begin = do_solid_solid_begin\n    psch.pre_solve = do_solid_solid_pre\n    psch.post_solve = do_solid_solid_post\n    psch.separate = do_solid_solid_end\n\n    ssench = self._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SENSOR)\n    ssench.begin = do_solid_goal_begin\n    ssench.separate = do_solid_goal_end\n\n    psench = self._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SENSOR)\n    psench.begin = do_solid_goal_begin\n    psench.separate = do_solid_goal_end\n\n    if closed_ends[0]:\n        self.add_box(\"_LeftWall\",[-1,-1,1,self.dims[1]+1], self.def_col, 0)\n    if closed_ends[1]:\n        self.add_box(\"_BottomWall\", [-1,-1,self.dims[0]+1, 1], self.def_col, 0);\n    if closed_ends[2]:\n        self.add_box(\"_RightWall\", [self.dims[0] - 1, -1, self.dims[0] + 1, self.dims[1] + 1], self.def_col, 0);\n    if closed_ends[3]:\n        self.add_box(\"_TopWall\", [-1, self.dims[1] - 1, self.dims[0] + 1, self.dims[1] + 1], self.def_col, 0);\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.attach_any_in_goal","title":"<code>attach_any_in_goal(goalname, duration, exclusions=[])</code>","text":"<p>Sets a victory condition in which any object can make it into the goal area (except those specified in exclusions)</p> <p>Parameters:</p> Name Type Description Default <code>goalname</code> <code>str</code> <p>the Virtual Tools name of the goal object</p> required <code>duration</code> <code>float</code> <p>the amount of time (in seconds) an object must remain in the goal</p> required <code>exclusions</code> <code>List[str]</code> <p>a list of Virtual Tools names of objects that will not trigger victory. Defaults to [].</p> <code>[]</code> Source code in <code>virtualtools/world/world.py</code> <pre><code>def attach_any_in_goal(self, goalname: str, duration: float, exclusions: List[str] = []):\n    \"\"\"Sets a victory condition in which any object can make it into the goal area (except those specified in exclusions)\n\n    Args:\n        goalname (str): the Virtual Tools name of the goal object\n        duration (float): the amount of time (in seconds) an object must remain in the goal\n        exclusions (List[str], optional): a list of Virtual Tools names of objects that will *not* trigger victory. Defaults to [].\n    \"\"\"        \n    self.goal_cond = VTCond_AnyInGoal(goalname, duration, self, exclusions)\n    self.goal_cond.attach_hooks()\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.attach_any_touch","title":"<code>attach_any_touch(objname, duration)</code>","text":"<p>Sets a victory condition in which any dynamic object must touch a specific object</p> <p>Parameters:</p> Name Type Description Default <code>objname</code> <code>str</code> <p>the Virtual Tools name of the target object to be touched</p> required <code>duration</code> <code>float</code> <p>the amount of time (in seconds) the objects must remain in contact</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def attach_any_touch(self, objname: str, duration: float):\n    \"\"\"Sets a victory condition in which any dynamic object must touch a specific object\n\n    Args:\n        objname (str): the Virtual Tools name of the target object to be touched\n        duration (float): the amount of time (in seconds) the objects must remain in contact\n    \"\"\"        \n    self.goal_cond = VTCond_AnyTouch(objname, duration, self)\n    self.goal_cond.attach_hooks()\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.attach_many_in_goal","title":"<code>attach_many_in_goal(goalname, objlist, duration)</code>","text":"<p>Sets a victory condition in which any of a set of objects must make it into a specific goal area</p> <p>Parameters:</p> Name Type Description Default <code>goalname</code> <code>str</code> <p>the Virtual Tools name of the goal object</p> required <code>objlist</code> <code>List[str]</code> <p>a list of Virtual Tools names of objects to go into the goal</p> required <code>duration</code> <code>float</code> <p>the amount of time (in seconds) an object must remain in the goal</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def attach_many_in_goal(self, goalname: str, objlist: List[str], duration: float):\n    \"\"\"Sets a victory condition in which any of a set of objects must make it into a specific goal area\n\n    Args:\n        goalname (str): the Virtual Tools name of the goal object\n        objlist (List[str]): a list of Virtual Tools names of objects to go into the goal\n        duration (float): the amount of time (in seconds) an object must remain in the goal\n    \"\"\"        \n    self.goal_cond = VTCond_ManyInGoal(goalname, objlist, duration, self)\n    self.goal_cond.attach_hooks()\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.attach_specific_in_goal","title":"<code>attach_specific_in_goal(goalname, objname, duration)</code>","text":"<p>Sets a victory condition in which a specific object must make it into a specific goal area</p> <p>Parameters:</p> Name Type Description Default <code>goalname</code> <code>str</code> <p>the Virtual Tools name of the goal object</p> required <code>objname</code> <code>str</code> <p>the Virtual Tools name of the target object to go into the goal</p> required <code>duration</code> <code>float</code> <p>the amount of time (in seconds) an object must remain in the goal</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def attach_specific_in_goal(self, goalname: str, objname: str, duration: float):\n    \"\"\"Sets a victory condition in which a specific object must make it into a specific goal area\n\n    Args:\n        goalname (str): the Virtual Tools name of the goal object\n        objname (str): the Virtual Tools name of the target object to go into the goal\n        duration (float): the amount of time (in seconds) an object must remain in the goal\n    \"\"\"        \n    self.goal_cond = VTCond_SpecificInGoal(goalname, objname, duration, self)\n    self.goal_cond.attach_hooks()\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.attach_specific_touch","title":"<code>attach_specific_touch(obj1, obj2, duration)</code>","text":"<p>Sets a victory condition in which two objects must come into contact</p> <p>Parameters:</p> Name Type Description Default <code>obj1</code> <code>str</code> <p>the Virtual Tools name of one of the target objects</p> required <code>obj2</code> <code>str</code> <p>the Virtual Tools name of the other target object</p> required <code>duration</code> <code>float</code> <p>the amount of time (in seconds) the objects must remain in contact</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def attach_specific_touch(self, obj1: str, obj2: str, duration: float):\n    \"\"\"Sets a victory condition in which two objects must come into contact\n\n    Args:\n        obj1 (str): the Virtual Tools name of one of the target objects\n        obj2 (str): the Virtual Tools name of the other target object\n        duration (float): the amount of time (in seconds) the objects must remain in contact\n    \"\"\"        \n    self.goal_cond = VTCond_SpecificTouch(obj1, obj2, duration, self)\n    self.goal_cond.attach_hooks()\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.check_circle_collision","title":"<code>check_circle_collision(pos, rad)</code>","text":"<p>Checks if there would be a colision with an object if a circular object were placed in the world</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>Tuple[float, float]</code> <p>the center of the hypothetical circular object</p> required <code>rad</code> <code>float</code> <p>the radius of the hypothetical circular object</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if there would be a colision, false if not</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def check_circle_collision(self, pos: Tuple[float, float], rad: float) -&gt; bool:\n    \"\"\"Checks if there would be a colision with an object if a circular object were placed in the world\n\n    Args:\n        pos (Tuple[float, float]): the center of the hypothetical circular object\n        rad (float): the radius of the hypothetical circular object\n\n    Returns:\n        bool: true if there would be a colision, false if not\n    \"\"\"        \n    tmpBody = pm.Body(1,1)\n    placeShape = pm.Circle(tmpBody, rad, pos)\n    placeShape.collision_type = COLTYPE_CHECKER\n    placeShape.sensor = True\n    self._cpSpace.step(.000001)\n\n    self.has_place_collision = False\n    squery = self._cpSpace.shape_query(placeShape)\n    return len(squery) &gt; 0\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.check_collision","title":"<code>check_collision(pos, verts)</code>","text":"<p>Checks whether placing a convex polygon in the world would cause a collision</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>Tuple[float, float]</code> <p>the position of the hypothetical polygon (where all vertices are calculated wrt)</p> required <code>verts</code> <code>List[Tuple[float, float]]</code> <p>a list of (x,y) vertices of the convex polygon, relative to the position</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if there would be a collision, false if not</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def check_collision(self, pos: Tuple[float, float], verts: List[Tuple[float, float]]) -&gt; bool:\n    \"\"\"Checks whether placing a convex polygon in the world would cause a collision\n\n    Args:\n        pos (Tuple[float, float]): the position of the hypothetical polygon (where all vertices are calculated wrt)\n        verts (List[Tuple[float, float]]): a list of (x,y) vertices of the convex polygon, relative to the position\n\n    Returns:\n        bool: true if there would be a collision, false if not\n    \"\"\"        \n    nvert = [(v[0]+pos[0], v[1]+pos[1]) for v in verts]\n    tmpBody = pm.Body(1,1)\n    placeShape = pm.Poly(tmpBody, nvert)\n    placeShape.collision_type = COLTYPE_CHECKER\n    placeShape.sensor = True\n    self._cpSpace.step(.000001)\n\n    self.has_place_collision = False\n    squery = self._cpSpace.shape_query(placeShape)\n    \"\"\" Code doesn't account for blockers (sensors)\n    # Update 12/12/23: I don't see why this wouldn't but if you're getting incorrect output, check the blockers!\n    if len(squery) == 0:\n        return False\n    else:\n        for sq in squery:\n            for p in sq.contact_point_set.points:\n                if p.distance &gt; 0:\n                    return True\n        return False\n    \"\"\"\n    return len(squery) &gt; 0\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.check_end","title":"<code>check_end()</code>","text":"<p>Returns whether the victory condition of the world has been cleared</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if victory is achieved; false if not (or if no condition exists)</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def check_end(self) -&gt; bool:\n    \"\"\"Returns whether the victory condition of the world has been cleared\n\n    Returns:\n        bool: true if victory is achieved; false if not (or if no condition exists)\n    \"\"\"        \n    if self.goal_cond is None:\n        return False\n    return self.goal_cond.is_won()\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.check_finishers","title":"<code>check_finishers()</code>","text":"<p>Makes sure there is a way to exit the world -- a victory condition and a win_callback that happens afterwards</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if goal_cond and win_callback exist, false otherwise</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def check_finishers(self) -&gt; bool:\n    \"\"\"Makes sure there is a way to exit the world -- a victory condition and a win_callback that happens afterwards\n\n    Returns:\n        bool: true if goal_cond and win_callback exist, false otherwise\n    \"\"\"        \n    return self.goal_cond is not None and self.win_callback is not None\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.distance_to_goal","title":"<code>distance_to_goal(point)</code>","text":"<p>Returns the distance between the nearest object achieving victory and the goal area / other object</p> <p>WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Tuple[float, float]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>description</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if no goal condition is specified</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def distance_to_goal(self, point: Tuple[float, float]) -&gt; float:\n    \"\"\"Returns the distance between the nearest object achieving victory and the goal area / other object\n\n    WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!\n\n    Args:\n        point (Tuple[float, float]): _description_\n\n    Returns:\n        float: _description_\n\n    Raises:\n        AssertionError: if no goal condition is specified\n    \"\"\"        \n    assert self.goal_cond, \"Goal condition must be specified to get distance\"\n    warnings.warn(\"This function is old and looks wrong - be careful using it\")\n    # Special case... requires getting two distances\n    if type(self.goal_cond) == VTCond_SpecificTouch:\n        o1 = self.get_object(self.goal_cond.o1)\n        o2 = self.get_object(self.goal_cond.o2)\n        #in this case, we actually want the distance between these two objects...\n        return np.abs(o1.distance_from_point([0,0]) - o2.distance_from_point([0,0])) #distance between these two objects is thing that matters\n    else:\n        gobj = self.get_object(self.goal_cond.goal)\n        return max(gobj.distance_from_point(point), 0)\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.distance_to_goal_container","title":"<code>distance_to_goal_container(point)</code>","text":"<p>Returns the distance between the nearest object achieving victory and the goal area / other object; specifies that for container objects, you want the distance to the top of the container</p> <p>WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Tuple[float, float]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def distance_to_goal_container(self, point: Tuple[float, float]):\n    \"\"\"Returns the distance between the nearest object achieving victory and the goal area / other object; specifies that for container objects, you want the distance to the top of the container\n\n    WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!\n\n\n    Args:\n        point (Tuple[float, float]): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    assert self.goal_cond, \"Goal condition must be specified to get distance\"\n    warnings.warn(\"This function is old and looks wrong - be careful using it\")\n    try:\n        # Special case... requires getting two distances\n        if type(self.goal_cond) == VTCond_SpecificTouch:\n            o1 = self.get_object(self.goal_cond.o1)\n            o2 = self.get_object(self.goal_cond.o2)\n            #in this case, we actually want the distance between these two objects...\n            return np.abs(o1.distance_from_point([0,0]) - o2.distance_from_point([0,0])) #distance between these two objects is thing that matters\n        else:\n            gobj = self.get_object(self.goal_cond.goal)\n            if gobj.type != 'Container':\n                return gobj.distance_from_point(point)\n            else:\n                if self.distance_to_goal(point) == 0:\n                    return 0\n                else:\n                    return distance_to_object(gobj, point)\n    except:\n        pdb.set_trace()\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.get_dynamic_objects","title":"<code>get_dynamic_objects()</code>","text":"<p>Returns a list of all dynamic (not static) objects in the world</p> <p>Returns:</p> Type Description <code>List[VTObject]</code> <p>List[VTObject]: a List of all of the dynamics VTObjects</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def get_dynamic_objects(self) -&gt; List[VTObject]:\n    \"\"\"Returns a list of all dynamic (not static) objects in the world\n\n    Returns:\n        List[VTObject]: a List of all of the dynamics VTObjects\n    \"\"\"        \n    return [self.objects[i] for i in self.objects.keys() if not self.objects[i].is_static()]\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.get_gravity","title":"<code>get_gravity()</code>","text":"<p>Returns the gravity in units/s^2 downwards</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>gravity</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def get_gravity(self) -&gt; float:\n    \"\"\"Returns the gravity in units/s^2 downwards\n\n    Returns:\n        float: gravity\n    \"\"\"        \n    return -self._cpSpace.gravity.y\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.get_object","title":"<code>get_object(name)</code>","text":"<p>Returns an object that exists in the world</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the Virtual Tools name flag of the object</p> required <p>Returns:</p> Name Type Description <code>VTObject</code> <code>VTObject</code> <p>the object within the world</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if the object doesn't exist</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def get_object(self, name: str) -&gt; VTObject:\n    \"\"\"Returns an object that exists in the world\n\n    Args:\n        name (str): the Virtual Tools name flag of the object\n\n    Returns:\n        VTObject: the object within the world\n\n    Raises:\n        AssertionError: if the object doesn't exist\n    \"\"\"        \n    assert name in self.objects.keys(), \"No object by that name: \" + name\n    return self.objects[name]\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.kick","title":"<code>kick(objectname, impulse, position)</code>","text":"<p>Applies an impulse to an object at a particular point</p> <p>Parameters:</p> Name Type Description Default <code>objectname</code> <code>str</code> <p>the Virtual Tools name of the object in this world</p> required <code>impulse</code> <code>Tuple[float, float]</code> <p>the impulse (momentum) vector</p> required <code>position</code> <code>Tuple[float, float]</code> <p>the point to apply the impulse to in world coordinates. Note: this must be inside the object!</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def kick(self, objectname: str, impulse: Tuple[float, float], position: Tuple[float, float]):\n    \"\"\"Applies an impulse to an object at a particular point\n\n    Args:\n        objectname (str): the Virtual Tools name of the object in this world\n        impulse (Tuple[float, float]): the impulse (momentum) vector\n        position (Tuple[float, float]): the point to apply the impulse to in world coordinates. Note: this must be inside the object!\n    \"\"\"        \n    o = self.get_object(objectname)\n    o.kick(impulse, position)\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.reset_collisions","title":"<code>reset_collisions()</code>","text":"<p>Clears out the collision events list</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def reset_collisions(self):\n    \"\"\"Clears out the collision events list\n    \"\"\"        \n    self._collision_events = []\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.set_gravity","title":"<code>set_gravity(val)</code>","text":"<p>Sets the gravity in units/s^2 downwards. Negative values make things fall \"up\"</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float</code> <p>gravity</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def set_gravity(self, val: float):\n    \"\"\"Sets the gravity in units/s^2 downwards. Negative values make things fall \"up\"\n\n    Args:\n        val (float): gravity\n    \"\"\"        \n    self._cpSpace.gravity = (0, -val)\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.step","title":"<code>step(t)</code>","text":"<p>Steps the world forward by t seconds. Not that this will not affect the precision of physics simulation; that is done via the <code>basic_timestep</code> value upon initialization</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>the amount of time (in seconds) to step forward</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def step(self, t: float):\n    \"\"\"Steps the world forward by t seconds. Not that this will not affect the precision of physics simulation; that is done via the `basic_timestep` value upon initialization\n\n    Args:\n        t (float): the amount of time (in seconds) to step forward\n    \"\"\"        \n    nsteps = int(np.floor(t / self.bts))\n    remtime = self.bts % t\n    self.time += t\n    for i in range(nsteps):\n        self._cpSpace.step(self.bts)\n        if self.check_end() and self.win_callback is not None:\n            self.win_callback()\n    if remtime / self.bts &gt; .01:\n        self._cpSpace.step(remtime)\n    if self.check_end() and self.win_callback is not None:\n        self.win_callback()\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.VTWorld.to_dict","title":"<code>to_dict()</code>","text":"<p>Outputs a JSON-serializable Dict describing the world</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if invalid object or goal types exist in the world. In theory this should never happen</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>a JSON-serializable Dict</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"Outputs a JSON-serializable Dict describing the world\n\n    Raises:\n        Exception: if invalid object or goal types exist in the world. In theory this should never happen\n\n    Returns:\n        Dict: a JSON-serializable Dict\n    \"\"\"        \n    wdict = dict()\n    wdict['dims'] = tuple(self.dims)\n    wdict['bts'] = self.bts\n    wdict['gravity'] = self.gravity\n    wdict['defaults'] = dict(density=self.def_density, friction=self.def_friction,\n                             elasticity=self.def_elasticity, color=self.def_col, bk_color=self.bk_col)\n\n    wdict['objects'] = dict()\n    for nm, o in self.objects.items():\n        attrs = dict(type=o.type, color=list(o.color), density=o.density,\n                     friction=o.friction, elasticity=o.elasticity)\n        if o.type == 'Poly':\n            attrs['vertices'] = _listify(o.vertices)\n        elif o.type == 'Ball':\n            attrs['position'] = list(o.position)\n            attrs['radius'] = o.radius\n        elif o.type == 'Segment':\n            attrs['p1'], attrs['p2'] = _listify(o.points)\n            attrs['width'] = o.r * 2\n        elif o.type == 'Container':\n            attrs['points'] = _listify(o.vertices)\n            attrs['width'] = o.r * 2\n            attrs['innerColor'] = o.inner_color\n            attrs['outerColor'] = o.outer_color\n        elif o.type == 'Goal':\n            attrs['vertices'] = _listify(o.vertices)\n        elif o.type == 'Compound':\n            attrs['polys'] = _listify(o.polys)\n        else:\n            raise Exception('Invalid object type provided')\n        wdict['objects'][nm] = attrs\n\n    wdict['blocks'] = dict()\n    for nm, b in self.blockers.items():\n        attrs = {'color': list(b.color), 'vertices': _listify(b.vertices)}\n        wdict['blocks'][nm] = attrs\n\n    wdict['constraints'] = dict()\n\n    if self.goal_cond is None:\n        wdict['gcond'] = None\n    else:\n        gc = self.goal_cond\n        if gc.type == 'AnyInGoal':\n            wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': '-',\n                              'exclusions': gc.excl, 'duration': gc.dur}\n        elif gc.type == 'SpecificInGoal':\n            wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': gc.obj, 'duration': gc.dur}\n        elif gc.type == 'ManyInGoal':\n            wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'objlist': gc.objlist, 'duration': gc.dur}\n        elif gc.type == \"AnyTouch\":\n            wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': '-', 'duration': gc.dur}\n        elif gc.type == 'SpecificTouch':\n            wdict['gcond'] = {'type': gc.type, 'goal': gc.o1, 'obj': gc.o2, 'duration': gc.dur}\n        else:\n            raise Exception('Invalid goal condition type provided')\n\n    return wdict\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.load_vt_from_dict","title":"<code>load_vt_from_dict(d)</code>","text":"<p>Takes a serializable Dict describing the world, and turns it into a VTWorld object</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Dict</code> <p>a serializable vesion of the world (e.g., from VTWorld.to_dict())</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if invalid object or goal types are described in the Dict</p> <p>Returns:</p> Name Type Description <code>VTWorld</code> <code>VTWorld</code> <p>the world described in the Dict</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def load_vt_from_dict(d: Dict) -&gt; VTWorld:\n    \"\"\"Takes a serializable Dict describing the world, and turns it into a VTWorld object\n\n    Args:\n        d (Dict): a serializable vesion of the world (e.g., from VTWorld.to_dict())\n\n    Raises:\n        Exception: if invalid object or goal types are described in the Dict\n\n    Returns:\n        VTWorld: the world described in the Dict\n    \"\"\"    \n    d = deepcopy(d)\n    def_elast = float(d['defaults']['elasticity'])\n    def_fric = float(d['defaults']['friction'])\n\n    vtw = VTWorld(d['dims'], d['gravity'], [False, False, False, False], d['bts'],\n                  float(d['defaults']['density']), def_elast, def_fric,\n                  word_to_color(d['defaults']['bk_color']), word_to_color(d['defaults']['color']))\n\n    for nm, o in d['objects'].items():\n        elasticity = float(o.get('elasticity', def_elast))\n        friction = float(o.get('friction', def_fric))\n        density = float(o.get('density', d['defaults']['density']))\n\n        if o['type'] == 'Poly':\n            vtw.add_poly(nm, o['vertices'], word_to_color(o['color']), density, elasticity, friction)\n        elif o['type'] == 'Ball':\n            vtw.add_ball(nm, o['position'], o['radius'], word_to_color(o['color']), density, elasticity, friction)\n        elif o['type'] == 'Segment':\n            vtw.add_segment(nm, o['p1'], o['p2'], o['width'], word_to_color(o['color']), density, elasticity, friction)\n        elif o['type'] == 'Container':\n            if 'innerColor' not in o:\n                if 'color' in o:\n                    ic = word_to_color(o['color'])\n                else:\n                    ic = None\n            else:\n                ic = word_to_color(o['innerColor'])\n            if 'outerColor' not in o:\n                oc = DEFAULT_COLOR\n            else:\n                oc = word_to_color(o['outerColor'])\n            vtw.add_container(nm, o['points'], o['width'], ic, oc, density, elasticity, friction)\n        elif o['type'] == 'Goal':\n            vtw.add_poly_goal(nm, o['vertices'], word_to_color(o['color']))\n        elif o['type'] == 'Compound':\n            vtw.add_compound(nm, o['polys'], word_to_color(o['color']), density, elasticity, friction)\n        else:\n            raise Exception(\"Invalid object type given: \" + o['type'])\n\n    for nm, b in d['blocks'].items():\n        vtw.add_poly_block(nm, b['vertices'], word_to_color(b['color']))\n\n    if d['gcond'] is not None:\n        g = d['gcond']\n        if g['type'] == 'AnyInGoal':\n            excl = g.get('exclusions', [])\n            vtw.attach_any_in_goal(g['goal'], float(g['duration']), excl)\n        elif g['type'] == 'SpecificInGoal':\n            vtw.attach_specific_in_goal(g['goal'], g['obj'], float(g['duration']))\n        elif g['type'] == 'ManyInGoal':\n            vtw.attach_many_in_goal(g['goal'], g['objlist'], float(g['duration']))\n        elif g['type'] == 'AnyTouch':\n            vtw.attach_any_touch(g['goal'], float(g['duration']))\n        elif g['type'] == 'SpecificTouch':\n            vtw.attach_specific_touch(g['goal'], g['obj'], float(g['duration']))\n        else:\n            raise Exception(\"In valid goal condition type given\")\n\n    return vtw\n</code></pre>"},{"location":"reference/virtualtools/#virtualtools.noisify_world","title":"<code>noisify_world(gameworld, noise_position_static=0.0, noise_position_moving=0.0, noise_collision_direction=0.0, noise_collision_elasticity=0.0, noise_gravity=0.0, noise_object_friction=0.0, noise_object_density=0.0, noise_object_elasticity=0.0)</code>","text":"<p>Creates a noisy version of a VTWorld, including: perceptual noise, collision noise, and property noise (NOTE: property noise currently is not implemented, except for gravity)</p> perceptual noise <p>Changes the location of objects by perturbing each objects' positions by a gaussian around the original location. The standard deviation of this is set separately for static and moving objects</p> collision noise <p>Noise in the dynamics of the system. This is added uncertainty whenever there is a collision. In pymunk, collisions are resolved by providing equal and opposite impulses at the point of collision; this noise perturbs both the direction and the magnitude of those impulses</p> property noise <p>Currently only provides uncertainty about the gravity of the world; in theory should also add noise to friction, density, and elasticities of each object</p> <p>Parameters:</p> Name Type Description Default <code>gameworld</code> <code>VTWorld</code> <p>the world to make noisy</p> required <code>noise_position_static</code> <code>float</code> <p>the sd of an isotropic gaussian describing perceptual uncertainty for static objects. Defaults to 0..</p> <code>0.0</code> <code>noise_position_moving</code> <code>float</code> <p>the sd of an isotropic gaussian describing perceptual uncertainty for moving objects. Defaults to 0..</p> <code>0.0</code> <code>noise_collision_direction</code> <code>float</code> <p>the sd of a wrapped gaussian describing collision impulse perturbations. Defaults to 0..</p> <code>0.0</code> <code>noise_collision_elasticity</code> <code>float</code> <p>the sd of the elasticity of the colision, which directly impacts the magnitude. Defaults to 0..</p> <code>0.0</code> <code>noise_gravity</code> <code>float</code> <p>the sd of a truncated gaussian centered at 1 which is multiplied by the true gravity (but cannot bring gravity below 0). Defaults to 0..</p> <code>0.0</code> <code>noise_object_friction</code> <code>float</code> <p>NOT IMPLEMENTED. Defaults to 0..</p> <code>0.0</code> <code>noise_object_density</code> <code>float</code> <p>NOT IMPLEMENTED. Defaults to 0..</p> <code>0.0</code> <code>noise_object_elasticity</code> <code>float</code> <p>NOT IMPLEMENTED. Defaults to 0..</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>VTWorld</code> <code>VTWorld</code> <p>a noisy version of the original world</p> Source code in <code>virtualtools/world/noisyworld.py</code> <pre><code>def noisify_world(gameworld: VTWorld,\n                  noise_position_static: float=0.,\n                  noise_position_moving: float=0.,\n                  noise_collision_direction: float=0.,\n                  noise_collision_elasticity: float=0.,\n                  noise_gravity: float=0.,\n                  noise_object_friction: float=0.,\n                  noise_object_density: float=0.,\n                  noise_object_elasticity: float=0.) -&gt; VTWorld:\n    \"\"\"Creates a noisy version of a VTWorld, including: perceptual noise, collision noise, and property noise\n    (NOTE: property noise currently is not implemented, except for gravity)\n\n    perceptual noise:\n        Changes the location of objects by perturbing each objects' positions by a gaussian around the original location. The standard deviation of this is set separately for static and moving objects\n\n    collision noise:\n        Noise in the dynamics of the system. This is added uncertainty whenever there is a collision. In pymunk, collisions are resolved by providing equal and opposite impulses at the point of collision; this noise perturbs both the direction and the magnitude of those impulses\n\n    property noise:\n        Currently only provides uncertainty about the gravity of the world; in theory should also add noise to friction, density, and elasticities of each object\n\n    Args:\n        gameworld (VTWorld): the world to make noisy\n        noise_position_static (float, optional): the sd of an isotropic gaussian describing perceptual uncertainty for static objects. Defaults to 0..\n        noise_position_moving (float, optional): the sd of an isotropic gaussian describing perceptual uncertainty for moving objects. Defaults to 0..\n        noise_collision_direction (float, optional): the sd of a wrapped gaussian describing collision impulse perturbations. Defaults to 0..\n        noise_collision_elasticity (float, optional): the sd of the elasticity of the colision, which directly impacts the magnitude. Defaults to 0..\n        noise_gravity (float, optional): the sd of a truncated gaussian centered at 1 which is multiplied by the true gravity (but cannot bring gravity below 0). Defaults to 0..\n        noise_object_friction (float, optional): NOT IMPLEMENTED. Defaults to 0..\n        noise_object_density (float, optional): NOT IMPLEMENTED. Defaults to 0..\n        noise_object_elasticity (float, optional): NOT IMPLEMENTED. Defaults to 0..\n\n    Returns:\n        VTWorld: a noisy version of the original world\n    \"\"\"    \n\n    w = gameworld.copy()\n\n    # Figure out the gravity (with adjustments)\n    if noise_gravity &gt; 0:\n        grav = w.gravity * trunc_norm(1, noise_gravity, 0)\n    else:\n        grav = w.gravity\n\n    # Turn things off (gravity &amp; callbacks)\n    w.gravity = 0\n    w._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SOLID)\n    w._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SOLID)\n    w._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SENSOR)\n    w._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SENSOR)\n\n    # Adjust the object positions and attributes\n    # First segment in to static vs not static &amp; adjust properties\n    wall_names = [\"_LeftWall\", \"_BottomWall\", \"_RightWall\", \"_TopWall\"]\n\n    # With static noise, group all touching objects and move them together\n    if noise_position_static &gt; 0:\n        # Make object groups (things that move together because they are touching)\n        obj_groups = []\n        objs = w.objects.values()\n        for i in range(len(objs) - 1):\n            o1 = objs[i]\n            if o1.name not in wall_names:\n                this_idx = -1\n                for idx, og in enumerate(obj_groups):\n                    if o1.name in [o.name for o in og]:\n                        this_idx = idx\n                if this_idx == -1:\n                    this_idx = len(obj_groups)\n                    obj_groups.append([o1])\n                for j in range(i + 1, len(objs)):\n                    o2 = objs[j]\n                    if o1.checkContact(o2):\n                        if o2.name not in [o.name for o in obj_groups[this_idx]] + wall_names:\n                            obj_groups[this_idx].append(o2)\n\n        # Now that the space is segmented, move all static items together\n        for og in obj_groups:\n            pos_change = noise_position_static * norm.rvs(size=2)\n            for o in og:\n                if o.is_static():\n                    _move_static(o, pos_change, w._cpSpace)\n                else:\n                    o.position += pos_change\n\n    # With moving noise, adjust objects individually but make sure they are still touching everything they already were\n    if noise_position_moving &gt; 0:\n        # Find the things that need to be moved and cache their original positions and touching objects\n        free_obj = []\n        orig_pos = {}\n        orig_vel = {}\n        touch_dict = {}\n        for onm, obj in w.objects.items():\n            if not obj.is_static():\n                free_obj.append(obj)\n                orig_pos[onm] = obj.position\n                orig_vel[onm] = obj.velocity\n\n                obj.velocity = (0, 0)\n                touch_dict[onm] = []\n                for onm2, obj2 in w.objects.items():\n                    if onm != onm2:\n                        if obj.checkContact(obj2):\n                            touch_dict[onm].append(obj2)\n\n        # Catch to ensure moving static objects doesn't produce an impossible configuration\n        noise_attempts = 0\n        max_attempts = 500\n        while len(free_obj) &gt; 0 and noise_attempts &lt; max_attempts:\n            noise_attempts += 1\n\n            # Randomly perturb everything\n            for o in free_obj:\n                o.position += noise_position_moving * norm.rvs(size=2)\n\n            # Take tiny steps to resolve overlaps\n            for i in range(10):\n                w._cpSpace.step(.1)\n\n            # Check that any contacts that existed already still remain - if not, reset\n            checked_contacts = []\n            for o in free_obj:\n                stillgood = True\n                touches = touch_dict[o.name]\n                for o2 in w.objects.values():\n                    if stillgood and o.name != o2.name:  # Make sure it's not the same thing; save compuatation\n                        if o.checkContact(o2):\n                            # If there's a contact, make sure that it's not a new one\n                            if o2 not in touches:\n                                stillgood = False\n                        else:\n                            # Otherwise, make sure if it's not touching it shouldn't be\n                            if o2 in touches:\n                                stillgood = False\n                if stillgood:\n                    checked_contacts.append(o.name)\n                    o._cpBody.sleep()\n                else:\n                    o.position = orig_pos[o.name]\n\n            # Now reduce free_obj\n\n            # things are getting messed up when we reduce free_obj in the w._cpSpace.step() phase to not include all objects. I'm not sure why,\n            # but the obvious fix for this for now is to just free up every object whenever we don't \"make it\" through to having no free objects\n            curr_free_obj = [\n                o for o in free_obj if o.name not in checked_contacts]\n            if len(curr_free_obj) &gt; 0:\n                for o in free_obj:\n                    o._cpBody.activate()  # wake things again if this isn't going to work\n            else:\n                free_obj = []\n\n        # Wake things back up\n        for onm, v in orig_vel.items():\n            o = w.objects[onm]\n            o._cpBody.activate()\n            o.velocity = v\n\n        # so as to prevent impossible configurations - just go back to original position\n        if noise_attempts &gt;= max_attempts:\n            for onm, v in orig_vel.items():\n                o = w.objects[onm]\n                o.velocity = v\n                o.position = orig_pos[onm]\n\n    # Set the callbacks to add noise\n    if noise_collision_direction &gt; 0 or noise_collision_elasticity &gt; 0:\n        def noisify_arbiter(arb):\n            # Make the restitution noisy\n            if noise_collision_elasticity &gt; 0:\n                arb.restitution += trunc_norm(0,\n                                              noise_collision_elasticity, -arb.restitution)\n            # Make the contact normals noisy\n            if noise_collision_direction &gt; 0:\n                newnorm = arb.contact_point_set.normal.rotated(\n                    wrapped_norm(0, noise_collision_direction))\n                setpoints = []\n                for cp in arb.contact_point_set.points:\n                    setpoints.append(pm.ContactPoint(\n                        list(cp.point_a), list(cp.point_b), cp.distance))\n                newcps = pm.ContactPointSet(list(newnorm), setpoints)\n                arb.contact_point_set = newcps\n\n        def do_solid_solid_pre(arb, space, data):\n            noisify_arbiter(arb)\n            return w._solid_solid_pre(arb, space, data)\n\n    else:\n        def do_solid_solid_pre(arb, space, data):\n            return w._solid_solid_pre(arb, space, data)\n\n    # Reset the world\n    w.gravity = grav\n\n    def do_solid_solid_begin(arb, space, data):\n        return w._solid_solid_begin(arb, space, data)\n\n    def do_solid_solid_post(arb, space, data):\n        return w._solid_solid_post(arb, space, data)\n\n    def do_solid_solid_end(arb, space, data):\n        return w._solid_solid_end(arb, space, data)\n\n    def do_solid_goal_begin(arb, space, data):\n        return w._solid_goal_begin(arb, space, data)\n\n    def do_solid_goal_end(arb, space, data):\n        return w._solid_goal_end(arb, space, data)\n\n    ssch = w._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SOLID)\n    ssch.begin = do_solid_solid_begin\n    ssch.pre_solve = do_solid_solid_pre\n    ssch.post_solve = do_solid_solid_post\n    ssch.separate = do_solid_solid_end\n\n    psch = w._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SOLID)\n    psch.begin = do_solid_solid_begin\n    psch.pre_solve = do_solid_solid_pre\n    psch.post_solve = do_solid_solid_post\n    psch.separate = do_solid_solid_end\n\n    ssench = w._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SENSOR)\n    ssench.begin = do_solid_goal_begin\n    ssench.separate = do_solid_goal_end\n\n    psench = w._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SENSOR)\n    psench.begin = do_solid_goal_begin\n    psench.separate = do_solid_goal_end\n\n    w._cpSpace.step(.0001)\n    return w\n</code></pre>"},{"location":"reference/virtualtools/generators/","title":"generators","text":""},{"location":"reference/virtualtools/generators/tpgenerator/","title":"tpgenerator","text":""},{"location":"reference/virtualtools/generators/vtgenerator/","title":"vtgenerator","text":""},{"location":"reference/virtualtools/generators/vtgenerator/#virtualtools.generators.vtgenerator.__all__","title":"<code>__all__ = ['VTGenerator', 'StaticGenerator']</code>  <code>module-attribute</code>","text":"<p>Keyword arguments: argument -- description Return: return_description</p>"},{"location":"reference/virtualtools/helpers/","title":"helpers","text":""},{"location":"reference/virtualtools/helpers/#virtualtools.helpers.any_line_intersections","title":"<code>any_line_intersections(vertices)</code>","text":"<p>Takes in a list of (x,y) vertices, checks if drawing segments between the vertices in order will have any intersections</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>List[Tuple[float, float]]</code> <p>a list of (x,y) vertices defining a series of connected segments</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>Raised if there are one or fewer vertices</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>returns true if any of those segments will overlap with one another</p> Source code in <code>virtualtools/helpers/geom.py</code> <pre><code>def any_line_intersections(vertices: List[Tuple[float, float]]) -&gt; bool:\n    \"\"\"Takes in a list of (x,y) vertices, checks if drawing segments between the vertices in order will have any intersections\n\n    Args:\n        vertices (List[Tuple[float, float]]): a list of (x,y) vertices defining a series of connected segments\n\n    Raises:\n        AssertionError: Raised if there are one or fewer vertices\n\n    Returns:\n        bool: returns true if any of those segments will overlap with one another\n    \"\"\"    \n    assert len(vertices) &gt; 1, \"Cannot find intersections with a single point\"\n    if len(vertices) &lt;= 3:\n        return False # There can be no intersections with two connected line segments\n    cverts = copy.deepcopy(vertices)\n    cverts.append(copy.copy(cverts[0]))\n\n    for i in range(len(vertices) - 1):\n        a = cverts[i]\n        b = cverts[i+1]\n        for j in range(i+1, len(vertices)):\n            c = cverts[j]\n            d = cverts[j+1]\n            if lines_intersect(a,b,c,d):\n                return True\n    return False\n</code></pre>"},{"location":"reference/virtualtools/helpers/#virtualtools.helpers.area_for_segment","title":"<code>area_for_segment(a, b, r)</code>","text":"<p>Returns the area of a segment defined by two endpoint vertices and a thickness (r) (assumes boxy ends)</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Tuple[float, float]</code> <p>the first endpoint of the segment</p> required <code>b</code> <code>Tuple[float, float]</code> <p>the second endpoint of the segment</p> required <code>r</code> <code>float</code> <p>the thickness of the segment</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the area of the defined segments</p> Source code in <code>virtualtools/helpers/geom.py</code> <pre><code>def area_for_segment(a: Tuple[float, float],\n                     b: Tuple[float, float],\n                     r: float) -&gt; float:\n    \"\"\"Returns the area of a segment defined by two endpoint vertices and a thickness (r) (assumes boxy ends)\n\n    Args:\n        a (Tuple[float, float]): the first endpoint of the segment\n        b (Tuple[float, float]): the second endpoint of the segment\n        r (float): the thickness of the segment\n\n    Returns:\n        float: the area of the defined segments\n    \"\"\"    \n    va = verts_to_vec2d(a)\n    vb = verts_to_vec2d(b)\n    return r * (np.pi*r + 2*va.get_distance(vb))\n</code></pre>"},{"location":"reference/virtualtools/helpers/#virtualtools.helpers.distance_to_object","title":"<code>distance_to_object(object, point)</code>","text":"<p>Returns the minimum distance between a point and the center of an object. Except for containers... then the minimum distance between the point and the container opening</p> <p>However this appears to be broken and depends on a function that no longer exists. I really hope this isn't needed anywhere... but if it is, please fix the <code>line_to_point_dist</code> function call!</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>VTObject</code> <p>a Virtual Tools VTObject</p> required <code>point</code> <code>Tuple[float, float]</code> <p>the point to calculate the distance to</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>always</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the distance between the object and point in world units</p> Source code in <code>virtualtools/helpers/physics.py</code> <pre><code>def distance_to_object(object: VTObject,\n                       point: Tuple[float, float]) -&gt; float:\n    \"\"\"Returns the minimum distance between a point and the center of an object. Except for containers... then the minimum distance between the point and the container opening\n\n    However this appears to be broken and depends on a function that no longer exists. I really hope this isn't needed anywhere... but if it is, please fix the `line_to_point_dist` function call!\n\n    Args:\n        object (VTObject): a Virtual Tools VTObject\n        point (Tuple[float, float]): the point to calculate the distance to\n\n    Raises:\n        NotImplementedError: always\n\n    Returns:\n        float: the distance between the object and point in world units\n    \"\"\"    \n    raise NotImplementedError('distance_to_object seems to be broken; please do not call')\n\n    if object.type != 'Container':\n        return _euclidDist(object.position, point)\n    else:\n        wall_list = object.seglist\n        wall_opening = wall_list[0]\n        wall_closing = wall_list[-1]\n\n        distance = line_to_point_dist(wall_opening, wall_closing, point)\n        return distance\n</code></pre>"},{"location":"reference/virtualtools/helpers/#virtualtools.helpers.object_bounding_box","title":"<code>object_bounding_box(object)</code>","text":"<p>Returns the bounding box of an object</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>VTObject</code> <p>a Virtual Tools world VTObject to calculate the bounding box of</p> required <p>Returns:</p> Type Description <code>Tuple[Tuple[float, float]]</code> <p>Tuple[Tuple[float, float]]: A set of ((right, bottom), (left, top)) coordinates of the bounding box. Returns None if the object is not a Ball, Poly, Container, or Compound type</p> Source code in <code>virtualtools/helpers/physics.py</code> <pre><code>def object_bounding_box(object: VTObject) -&gt; Tuple[Tuple[float, float]]:\n    \"\"\"Returns the bounding box of an object\n\n    Args:\n        object (VTObject): a Virtual Tools world VTObject to calculate the bounding box of\n\n    Returns:\n        Tuple[Tuple[float, float]]: A set of ((right, bottom), (left, top)) coordinates of the bounding box. Returns None if the object is not a Ball, Poly, Container, or Compound type\n    \"\"\"    \n    bb = [0,0]\n    if object.type == 'Ball':\n        bb[0] = [object.position[0] - object.radius, object.position[1] - object.radius]\n        bb[1] = [object.position[0] + object.radius, object.position[1] + object.radius]\n    elif object.type == 'Poly' or object.type == 'Container':\n        vert_x = [vert[0] for vert in object.vertices]\n        vert_y = [vert[1] for vert in object.vertices]\n        bb[0] = [min(vert_x), min(vert_y)]\n        bb[1] = [max(vert_x), max(vert_y)]\n    elif object.type == 'Compound':\n        vert_x = [vert[0] for o in object.polys for vert in o ]\n        vert_y = [vert[1] for o in object.polys for vert in o ]\n        bb[0] = [min(vert_x), min(vert_y)]\n        bb[1] = [max(vert_x), max(vert_y)]\n    else:\n        bb = None\n    return bb\n</code></pre>"},{"location":"reference/virtualtools/helpers/#virtualtools.helpers.poly_to_vec2d","title":"<code>poly_to_vec2d(vertices)</code>","text":"<p>Translates a list of (x,y) vertices to a list of pymunk vectors</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>List[Tuple[float, float]]</code> <p>a list of (x,y) vertices to translate</p> required <p>Returns:</p> Type Description <code>List[Vec2d]</code> <p>List[pm.Vec2d]: A list of pymunk Vec2d objects with the same points</p> Source code in <code>virtualtools/helpers/pmhelp.py</code> <pre><code>def poly_to_vec2d(vertices: List[Tuple[float, float]]) -&gt; List[pm.Vec2d]:\n    \"\"\"Translates a list of (x,y) vertices to a list of pymunk vectors\n\n    Args:\n        vertices (List[Tuple[float, float]]): a list of (x,y) vertices to translate\n\n    Returns:\n        List[pm.Vec2d]: A list of pymunk Vec2d objects with the same points\n    \"\"\"    \n    return [verts_to_vec2d(v) for v in vertices]\n</code></pre>"},{"location":"reference/virtualtools/helpers/#virtualtools.helpers.segs_to_poly","title":"<code>segs_to_poly(seglist, r)</code>","text":"<p>Transforms a set of connected line segments with a width into a set of convex hulls</p> <p>Parameters:</p> Name Type Description Default <code>seglist</code> <code>List[Tuple[float, float]]</code> <p>a list of [x,y] vertices defining the line segments in order (eg the first segment is defined as seglist[0] to seglist[1], the second from seglist[1] to seglist[2], etc)</p> required <code>r</code> <code>float</code> <p>the width of the bars that these segments will be transformed into</p> required <p>Returns:</p> Type Description <code>List[List[Tuple[float, float]]]</code> <p>List[List[Tuple[float, float]]]: a list of convex hulls -- each defined as a list of [x,y] vertices with CCW winding</p> Source code in <code>virtualtools/helpers/geom.py</code> <pre><code>def segs_to_poly(seglist: List[Tuple[float, float]],\n                 r: float) -&gt; List[List[Tuple[float, float]]]:\n    \"\"\"Transforms a set of connected line segments with a width into a set of convex hulls\n\n    Args:\n        seglist (List[Tuple[float, float]]): a list of [x,y] vertices defining the line segments in order (eg the first segment is defined as seglist[0] to seglist[1], the second from seglist[1] to seglist[2], etc)\n        r (float): the width of the bars that these segments will be transformed into\n\n    Returns:\n        List[List[Tuple[float, float]]]: a list of convex hulls -- each defined as a list of [x,y] vertices with CCW winding\n    \"\"\"\n    vlist = [verts_to_vec2d(v) for v in seglist]\n    # Start by figuring out the initial edge (ensure ccw winding)\n    iseg = vlist[1] - vlist[0]\n    ipt = vlist[0]\n    iang = iseg.angle\n    if iang &lt;= (-np.pi / 4.) and iang &gt;= (-np.pi * 3. / 4.):\n        # Going downwards\n        prev1 = (ipt.x - r, ipt.y)\n        prev2 = (ipt.x + r, ipt.y)\n    elif iang &gt;= (np.pi / 4.) and iang &lt;= (np.pi * 3. / 4.):\n        # Going upwards\n        prev1 = (ipt.x + r, ipt.y)\n        prev2 = (ipt.x - r, ipt.y)\n    elif iang &gt;= (-np.pi / 4.) and iang &lt;= (np.pi / 4.):\n        # Going rightwards\n        prev1 = (ipt.x, ipt.y - r)\n        prev2 = (ipt.x, ipt.y + r)\n    else:\n        # Going leftwards\n        prev1 = (ipt.x, ipt.y + r)\n        prev2 = (ipt.x, ipt.y - r)\n\n    polylist = []\n    for i in range(1, len(vlist)-1):\n        pi = vlist[i]\n        pim = vlist[i-1]\n        pip = vlist[i+1]\n        sm = pim - pi\n        sp = pip - pi\n        # Get the angle of intersetction between two lines\n        angm = sm.angle\n        angp = sp.angle\n        angi = (angm - angp) % (2*np.pi)\n        # Find the midpoint of this angle and turn it back into a unit vector\n        angn = (angp + (angi / 2.)) % (2*np.pi)\n        if angn &lt; 0:\n            angn += 2*np.pi\n        unitn = pm.Vec2d(np.cos(angn), np.sin(angn))\n        #unitn = pm.Vec2d.unit()\n        #unitn.angle = angn\n        xdiff = r if unitn.x &gt;= 0 else -r\n        ydiff = r if unitn.y &gt;= 0 else -r\n        next3 = (pi.x + xdiff, pi.y + ydiff)\n        next4 = (pi.x - xdiff, pi.y - ydiff)\n        # Ensure appropriate winding -- next3 should be on the left of next4\n        if _isleft(prev2, next3, next4):\n            tmp = next4\n            next4 = next3\n            next3 = tmp\n        polylist.append((prev1, prev2, next3, next4))\n        prev1 = next4\n        prev2 = next3\n\n    # Finish by figuring out the final edge\n    fseg = vlist[-2] - vlist[-1]\n    fpt = vlist[-1]\n    fang = fseg.angle\n    if fang &lt;= (-np.pi / 4.) and fang &gt;= (-np.pi * 3. / 4.):\n        # Coming from downwards\n        next3 = (fpt.x - r, fpt.y)\n        next4 = (fpt.x + r, fpt.y)\n    elif fang &gt;= (np.pi / 4.) and fang &lt;= (np.pi * 3. / 4.):\n        # Coming from upwards\n        next3 = (fpt.x + r, fpt.y)\n        next4 = (fpt.x - r, fpt.y)\n    elif fang &gt;= (-np.pi / 4.) and fang &lt;= (np.pi / 4.):\n        # Coming from rightwards\n        next3 = (fpt.x, fpt.y - r)\n        next4 = (fpt.x, fpt.y + r)\n    else:\n        # Coming from leftwards\n        next3 = (fpt.x, fpt.y + r)\n        next4 = (fpt.x, fpt.y - r)\n    polylist.append((prev1, prev2, next3, next4))\n    return polylist\n</code></pre>"},{"location":"reference/virtualtools/helpers/#virtualtools.helpers.verts_to_vec2d","title":"<code>verts_to_vec2d(vertex)</code>","text":"<p>_Translates a vertex defined as (x,y) into a pymunk vector</p> <p>Parameters:</p> Name Type Description Default <code>vertex</code> <code>Annotated[Tuple[float], 2]</code> <p>An (x,y) point</p> required <p>Returns:</p> Type Description <code>Vec2d</code> <p>pm.Vec2d: The same point defined as a pymunk Vec2d object</p> Source code in <code>virtualtools/helpers/pmhelp.py</code> <pre><code>def verts_to_vec2d(vertex: Annotated[Tuple[float], 2]) -&gt; pm.Vec2d:\n    \"\"\"_Translates a vertex defined as (x,y) into a pymunk vector\n\n    Args:\n        vertex (Annotated[Tuple[float], 2]): An (x,y) point\n\n    Returns:\n        pm.Vec2d: The same point defined as a pymunk Vec2d object\n    \"\"\"\n    return pm.Vec2d(vertex[0], vertex[1])\n</code></pre>"},{"location":"reference/virtualtools/helpers/#virtualtools.helpers.word_to_color","title":"<code>word_to_color(colorname)</code>","text":"<p>Converts a string into (r,g,b,a) color values</p> <p>Parameters:</p> Name Type Description Default <code>colorname</code> <code>str</code> <p>The name of the color to translate. Must be in the set of ['blue', 'red', 'green', 'black', 'white', 'grey', 'gray', 'lightgrey', 'none']</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>Raised if the color name is not in the values given above</p> <p>Returns:</p> Name Type Description <code>Tuple</code> <p>A length-4 tuple defining an RGBA color</p> Source code in <code>virtualtools/helpers/misc.py</code> <pre><code>def word_to_color(colorname: str):\n    \"\"\"Converts a string into (r,g,b,a) color values\n\n    Args:\n        colorname (str): The name of the color to translate. Must be in the set of ['blue', 'red', 'green', 'black', 'white', 'grey', 'gray', 'lightgrey', 'none']\n\n    Raises:\n        Exception: Raised if the color name is not in the values given above\n\n    Returns:\n        Tuple: A length-4 tuple defining an RGBA color\n    \"\"\"    \n    if colorname is None:\n        return None\n    try:\n        cvec = [int(c) for c in colorname]\n        return cvec\n    except:\n        if colorname == 0:\n            return (0, 0, 0, 255)\n        c = colorname.lower()\n        if c == 'blue':\n            return (0,0,255,255)\n        elif c == 'red':\n            return (255,0,0,255)\n        elif c == 'green':\n            return (0,255,0,255)\n        elif c == 'black':\n            return (0,0,0,255)\n        elif c == 'white':\n            return (255,255,255,255)\n        elif c == 'grey' or c == 'gray':\n            return (127,127,127,255)\n        elif c == 'lightgrey':\n            return (191,191,191,255)\n        elif c == 'none':\n            return (0, 0, 0, 0)\n        else:\n            raise Exception('Color name not known: ' + c)\n</code></pre>"},{"location":"reference/virtualtools/helpers/geom/","title":"geom","text":""},{"location":"reference/virtualtools/helpers/geom/#virtualtools.helpers.geom.any_line_intersections","title":"<code>any_line_intersections(vertices)</code>","text":"<p>Takes in a list of (x,y) vertices, checks if drawing segments between the vertices in order will have any intersections</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>List[Tuple[float, float]]</code> <p>a list of (x,y) vertices defining a series of connected segments</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>Raised if there are one or fewer vertices</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>returns true if any of those segments will overlap with one another</p> Source code in <code>virtualtools/helpers/geom.py</code> <pre><code>def any_line_intersections(vertices: List[Tuple[float, float]]) -&gt; bool:\n    \"\"\"Takes in a list of (x,y) vertices, checks if drawing segments between the vertices in order will have any intersections\n\n    Args:\n        vertices (List[Tuple[float, float]]): a list of (x,y) vertices defining a series of connected segments\n\n    Raises:\n        AssertionError: Raised if there are one or fewer vertices\n\n    Returns:\n        bool: returns true if any of those segments will overlap with one another\n    \"\"\"    \n    assert len(vertices) &gt; 1, \"Cannot find intersections with a single point\"\n    if len(vertices) &lt;= 3:\n        return False # There can be no intersections with two connected line segments\n    cverts = copy.deepcopy(vertices)\n    cverts.append(copy.copy(cverts[0]))\n\n    for i in range(len(vertices) - 1):\n        a = cverts[i]\n        b = cverts[i+1]\n        for j in range(i+1, len(vertices)):\n            c = cverts[j]\n            d = cverts[j+1]\n            if lines_intersect(a,b,c,d):\n                return True\n    return False\n</code></pre>"},{"location":"reference/virtualtools/helpers/geom/#virtualtools.helpers.geom.area_for_segment","title":"<code>area_for_segment(a, b, r)</code>","text":"<p>Returns the area of a segment defined by two endpoint vertices and a thickness (r) (assumes boxy ends)</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Tuple[float, float]</code> <p>the first endpoint of the segment</p> required <code>b</code> <code>Tuple[float, float]</code> <p>the second endpoint of the segment</p> required <code>r</code> <code>float</code> <p>the thickness of the segment</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the area of the defined segments</p> Source code in <code>virtualtools/helpers/geom.py</code> <pre><code>def area_for_segment(a: Tuple[float, float],\n                     b: Tuple[float, float],\n                     r: float) -&gt; float:\n    \"\"\"Returns the area of a segment defined by two endpoint vertices and a thickness (r) (assumes boxy ends)\n\n    Args:\n        a (Tuple[float, float]): the first endpoint of the segment\n        b (Tuple[float, float]): the second endpoint of the segment\n        r (float): the thickness of the segment\n\n    Returns:\n        float: the area of the defined segments\n    \"\"\"    \n    va = verts_to_vec2d(a)\n    vb = verts_to_vec2d(b)\n    return r * (np.pi*r + 2*va.get_distance(vb))\n</code></pre>"},{"location":"reference/virtualtools/helpers/geom/#virtualtools.helpers.geom.segs_to_poly","title":"<code>segs_to_poly(seglist, r)</code>","text":"<p>Transforms a set of connected line segments with a width into a set of convex hulls</p> <p>Parameters:</p> Name Type Description Default <code>seglist</code> <code>List[Tuple[float, float]]</code> <p>a list of [x,y] vertices defining the line segments in order (eg the first segment is defined as seglist[0] to seglist[1], the second from seglist[1] to seglist[2], etc)</p> required <code>r</code> <code>float</code> <p>the width of the bars that these segments will be transformed into</p> required <p>Returns:</p> Type Description <code>List[List[Tuple[float, float]]]</code> <p>List[List[Tuple[float, float]]]: a list of convex hulls -- each defined as a list of [x,y] vertices with CCW winding</p> Source code in <code>virtualtools/helpers/geom.py</code> <pre><code>def segs_to_poly(seglist: List[Tuple[float, float]],\n                 r: float) -&gt; List[List[Tuple[float, float]]]:\n    \"\"\"Transforms a set of connected line segments with a width into a set of convex hulls\n\n    Args:\n        seglist (List[Tuple[float, float]]): a list of [x,y] vertices defining the line segments in order (eg the first segment is defined as seglist[0] to seglist[1], the second from seglist[1] to seglist[2], etc)\n        r (float): the width of the bars that these segments will be transformed into\n\n    Returns:\n        List[List[Tuple[float, float]]]: a list of convex hulls -- each defined as a list of [x,y] vertices with CCW winding\n    \"\"\"\n    vlist = [verts_to_vec2d(v) for v in seglist]\n    # Start by figuring out the initial edge (ensure ccw winding)\n    iseg = vlist[1] - vlist[0]\n    ipt = vlist[0]\n    iang = iseg.angle\n    if iang &lt;= (-np.pi / 4.) and iang &gt;= (-np.pi * 3. / 4.):\n        # Going downwards\n        prev1 = (ipt.x - r, ipt.y)\n        prev2 = (ipt.x + r, ipt.y)\n    elif iang &gt;= (np.pi / 4.) and iang &lt;= (np.pi * 3. / 4.):\n        # Going upwards\n        prev1 = (ipt.x + r, ipt.y)\n        prev2 = (ipt.x - r, ipt.y)\n    elif iang &gt;= (-np.pi / 4.) and iang &lt;= (np.pi / 4.):\n        # Going rightwards\n        prev1 = (ipt.x, ipt.y - r)\n        prev2 = (ipt.x, ipt.y + r)\n    else:\n        # Going leftwards\n        prev1 = (ipt.x, ipt.y + r)\n        prev2 = (ipt.x, ipt.y - r)\n\n    polylist = []\n    for i in range(1, len(vlist)-1):\n        pi = vlist[i]\n        pim = vlist[i-1]\n        pip = vlist[i+1]\n        sm = pim - pi\n        sp = pip - pi\n        # Get the angle of intersetction between two lines\n        angm = sm.angle\n        angp = sp.angle\n        angi = (angm - angp) % (2*np.pi)\n        # Find the midpoint of this angle and turn it back into a unit vector\n        angn = (angp + (angi / 2.)) % (2*np.pi)\n        if angn &lt; 0:\n            angn += 2*np.pi\n        unitn = pm.Vec2d(np.cos(angn), np.sin(angn))\n        #unitn = pm.Vec2d.unit()\n        #unitn.angle = angn\n        xdiff = r if unitn.x &gt;= 0 else -r\n        ydiff = r if unitn.y &gt;= 0 else -r\n        next3 = (pi.x + xdiff, pi.y + ydiff)\n        next4 = (pi.x - xdiff, pi.y - ydiff)\n        # Ensure appropriate winding -- next3 should be on the left of next4\n        if _isleft(prev2, next3, next4):\n            tmp = next4\n            next4 = next3\n            next3 = tmp\n        polylist.append((prev1, prev2, next3, next4))\n        prev1 = next4\n        prev2 = next3\n\n    # Finish by figuring out the final edge\n    fseg = vlist[-2] - vlist[-1]\n    fpt = vlist[-1]\n    fang = fseg.angle\n    if fang &lt;= (-np.pi / 4.) and fang &gt;= (-np.pi * 3. / 4.):\n        # Coming from downwards\n        next3 = (fpt.x - r, fpt.y)\n        next4 = (fpt.x + r, fpt.y)\n    elif fang &gt;= (np.pi / 4.) and fang &lt;= (np.pi * 3. / 4.):\n        # Coming from upwards\n        next3 = (fpt.x + r, fpt.y)\n        next4 = (fpt.x - r, fpt.y)\n    elif fang &gt;= (-np.pi / 4.) and fang &lt;= (np.pi / 4.):\n        # Coming from rightwards\n        next3 = (fpt.x, fpt.y - r)\n        next4 = (fpt.x, fpt.y + r)\n    else:\n        # Coming from leftwards\n        next3 = (fpt.x, fpt.y + r)\n        next4 = (fpt.x, fpt.y - r)\n    polylist.append((prev1, prev2, next3, next4))\n    return polylist\n</code></pre>"},{"location":"reference/virtualtools/helpers/misc/","title":"misc","text":""},{"location":"reference/virtualtools/helpers/misc/#virtualtools.helpers.misc.word_to_color","title":"<code>word_to_color(colorname)</code>","text":"<p>Converts a string into (r,g,b,a) color values</p> <p>Parameters:</p> Name Type Description Default <code>colorname</code> <code>str</code> <p>The name of the color to translate. Must be in the set of ['blue', 'red', 'green', 'black', 'white', 'grey', 'gray', 'lightgrey', 'none']</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>Raised if the color name is not in the values given above</p> <p>Returns:</p> Name Type Description <code>Tuple</code> <p>A length-4 tuple defining an RGBA color</p> Source code in <code>virtualtools/helpers/misc.py</code> <pre><code>def word_to_color(colorname: str):\n    \"\"\"Converts a string into (r,g,b,a) color values\n\n    Args:\n        colorname (str): The name of the color to translate. Must be in the set of ['blue', 'red', 'green', 'black', 'white', 'grey', 'gray', 'lightgrey', 'none']\n\n    Raises:\n        Exception: Raised if the color name is not in the values given above\n\n    Returns:\n        Tuple: A length-4 tuple defining an RGBA color\n    \"\"\"    \n    if colorname is None:\n        return None\n    try:\n        cvec = [int(c) for c in colorname]\n        return cvec\n    except:\n        if colorname == 0:\n            return (0, 0, 0, 255)\n        c = colorname.lower()\n        if c == 'blue':\n            return (0,0,255,255)\n        elif c == 'red':\n            return (255,0,0,255)\n        elif c == 'green':\n            return (0,255,0,255)\n        elif c == 'black':\n            return (0,0,0,255)\n        elif c == 'white':\n            return (255,255,255,255)\n        elif c == 'grey' or c == 'gray':\n            return (127,127,127,255)\n        elif c == 'lightgrey':\n            return (191,191,191,255)\n        elif c == 'none':\n            return (0, 0, 0, 0)\n        else:\n            raise Exception('Color name not known: ' + c)\n</code></pre>"},{"location":"reference/virtualtools/helpers/physics/","title":"physics","text":""},{"location":"reference/virtualtools/helpers/physics/#virtualtools.helpers.physics.distance_to_object","title":"<code>distance_to_object(object, point)</code>","text":"<p>Returns the minimum distance between a point and the center of an object. Except for containers... then the minimum distance between the point and the container opening</p> <p>However this appears to be broken and depends on a function that no longer exists. I really hope this isn't needed anywhere... but if it is, please fix the <code>line_to_point_dist</code> function call!</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>VTObject</code> <p>a Virtual Tools VTObject</p> required <code>point</code> <code>Tuple[float, float]</code> <p>the point to calculate the distance to</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>always</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the distance between the object and point in world units</p> Source code in <code>virtualtools/helpers/physics.py</code> <pre><code>def distance_to_object(object: VTObject,\n                       point: Tuple[float, float]) -&gt; float:\n    \"\"\"Returns the minimum distance between a point and the center of an object. Except for containers... then the minimum distance between the point and the container opening\n\n    However this appears to be broken and depends on a function that no longer exists. I really hope this isn't needed anywhere... but if it is, please fix the `line_to_point_dist` function call!\n\n    Args:\n        object (VTObject): a Virtual Tools VTObject\n        point (Tuple[float, float]): the point to calculate the distance to\n\n    Raises:\n        NotImplementedError: always\n\n    Returns:\n        float: the distance between the object and point in world units\n    \"\"\"    \n    raise NotImplementedError('distance_to_object seems to be broken; please do not call')\n\n    if object.type != 'Container':\n        return _euclidDist(object.position, point)\n    else:\n        wall_list = object.seglist\n        wall_opening = wall_list[0]\n        wall_closing = wall_list[-1]\n\n        distance = line_to_point_dist(wall_opening, wall_closing, point)\n        return distance\n</code></pre>"},{"location":"reference/virtualtools/helpers/physics/#virtualtools.helpers.physics.object_bounding_box","title":"<code>object_bounding_box(object)</code>","text":"<p>Returns the bounding box of an object</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>VTObject</code> <p>a Virtual Tools world VTObject to calculate the bounding box of</p> required <p>Returns:</p> Type Description <code>Tuple[Tuple[float, float]]</code> <p>Tuple[Tuple[float, float]]: A set of ((right, bottom), (left, top)) coordinates of the bounding box. Returns None if the object is not a Ball, Poly, Container, or Compound type</p> Source code in <code>virtualtools/helpers/physics.py</code> <pre><code>def object_bounding_box(object: VTObject) -&gt; Tuple[Tuple[float, float]]:\n    \"\"\"Returns the bounding box of an object\n\n    Args:\n        object (VTObject): a Virtual Tools world VTObject to calculate the bounding box of\n\n    Returns:\n        Tuple[Tuple[float, float]]: A set of ((right, bottom), (left, top)) coordinates of the bounding box. Returns None if the object is not a Ball, Poly, Container, or Compound type\n    \"\"\"    \n    bb = [0,0]\n    if object.type == 'Ball':\n        bb[0] = [object.position[0] - object.radius, object.position[1] - object.radius]\n        bb[1] = [object.position[0] + object.radius, object.position[1] + object.radius]\n    elif object.type == 'Poly' or object.type == 'Container':\n        vert_x = [vert[0] for vert in object.vertices]\n        vert_y = [vert[1] for vert in object.vertices]\n        bb[0] = [min(vert_x), min(vert_y)]\n        bb[1] = [max(vert_x), max(vert_y)]\n    elif object.type == 'Compound':\n        vert_x = [vert[0] for o in object.polys for vert in o ]\n        vert_y = [vert[1] for o in object.polys for vert in o ]\n        bb[0] = [min(vert_x), min(vert_y)]\n        bb[1] = [max(vert_x), max(vert_y)]\n    else:\n        bb = None\n    return bb\n</code></pre>"},{"location":"reference/virtualtools/helpers/pmhelp/","title":"pmhelp","text":""},{"location":"reference/virtualtools/helpers/pmhelp/#virtualtools.helpers.pmhelp.poly_to_vec2d","title":"<code>poly_to_vec2d(vertices)</code>","text":"<p>Translates a list of (x,y) vertices to a list of pymunk vectors</p> <p>Parameters:</p> Name Type Description Default <code>vertices</code> <code>List[Tuple[float, float]]</code> <p>a list of (x,y) vertices to translate</p> required <p>Returns:</p> Type Description <code>List[Vec2d]</code> <p>List[pm.Vec2d]: A list of pymunk Vec2d objects with the same points</p> Source code in <code>virtualtools/helpers/pmhelp.py</code> <pre><code>def poly_to_vec2d(vertices: List[Tuple[float, float]]) -&gt; List[pm.Vec2d]:\n    \"\"\"Translates a list of (x,y) vertices to a list of pymunk vectors\n\n    Args:\n        vertices (List[Tuple[float, float]]): a list of (x,y) vertices to translate\n\n    Returns:\n        List[pm.Vec2d]: A list of pymunk Vec2d objects with the same points\n    \"\"\"    \n    return [verts_to_vec2d(v) for v in vertices]\n</code></pre>"},{"location":"reference/virtualtools/helpers/pmhelp/#virtualtools.helpers.pmhelp.verts_to_vec2d","title":"<code>verts_to_vec2d(vertex)</code>","text":"<p>_Translates a vertex defined as (x,y) into a pymunk vector</p> <p>Parameters:</p> Name Type Description Default <code>vertex</code> <code>Annotated[Tuple[float], 2]</code> <p>An (x,y) point</p> required <p>Returns:</p> Type Description <code>Vec2d</code> <p>pm.Vec2d: The same point defined as a pymunk Vec2d object</p> Source code in <code>virtualtools/helpers/pmhelp.py</code> <pre><code>def verts_to_vec2d(vertex: Annotated[Tuple[float], 2]) -&gt; pm.Vec2d:\n    \"\"\"_Translates a vertex defined as (x,y) into a pymunk vector\n\n    Args:\n        vertex (Annotated[Tuple[float], 2]): An (x,y) point\n\n    Returns:\n        pm.Vec2d: The same point defined as a pymunk Vec2d object\n    \"\"\"\n    return pm.Vec2d(vertex[0], vertex[1])\n</code></pre>"},{"location":"reference/virtualtools/interfaces/","title":"interfaces","text":""},{"location":"reference/virtualtools/interfaces/gameTypes/","title":"gameTypes","text":""},{"location":"reference/virtualtools/interfaces/oneball/","title":"oneball","text":"<p>Interface for a level that includes dropping a</p>"},{"location":"reference/virtualtools/interfaces/phyre_actions/","title":"phyre_actions","text":""},{"location":"reference/virtualtools/interfaces/running/","title":"running","text":""},{"location":"reference/virtualtools/interfaces/simpledropper/","title":"simpledropper","text":""},{"location":"reference/virtualtools/interfaces/simpledropper/#virtualtools.interfaces.simpledropper.__all__","title":"<code>__all__ = ['SimpleDropper', 'make_default_simple_world']</code>  <code>module-attribute</code>","text":"<p>A class for running SimpleDropper games (ones with easy geometry, a single tool to drop, and the goal of hitting a certain point on the ground with one object)</p> SimpleDropper game dictionaries should have the following entries <ul> <li>'world': a pyGameWorld world dict. This should always have an object            named 'GoalBall' that is expected to hit the ground. Also not            allowed to have any moveable compound objects</li> <li>'dropper': a list of [[x,y], ...] vertices for the tool to drop (must be              a convex polygon)</li> <li>'goal': a range [xmin, xmax] for where the object should hit</li> <li>'droprange': a range [xmin, xmax] where the tool can be dropped</li> </ul>"},{"location":"reference/virtualtools/interfaces/simpledropper/#virtualtools.interfaces.simpledropper.SimpleDropper","title":"<code>SimpleDropper</code>","text":"<p>Initializes a SimpleDropper</p> <p>Parameters:</p> Name Type Description Default <code>gamedict</code> <code>[dict]</code> <p>defined as above</p> required <code>record_timestep</code> <code>[float]</code> <p>how often to record positions</p> <code>0.1</code> <code>world_timestep</code> <code>[float]</code> <p>physics timestep for updating</p> <code>0.01</code> Source code in <code>virtualtools/interfaces/simpledropper.py</code> <pre><code>class SimpleDropper:\n\n    \"\"\"Initializes a SimpleDropper\n\n    Args:\n        gamedict [dict]: defined as above\n        record_timestep [float]: how often to record positions\n        world_timestep [float]: physics timestep for updating\n    \"\"\"\n    def __init__(self, gamedict, record_timestep=0.1, world_timestep=0.01,\n                 max_time=20.):\n\n        # Check the cleanliness of the world\n        world = gamedict['world']\n        assert 'GoalBall' in world['objects'].keys(),\\\n            \"Must have GoalBall object included\"\n        for onm, o in world['objects'].items():\n            if o[\"density\"] &gt; 0:\n                assert o['type'] not in ['Compound', 'Container'],\\\n                    \"Not allowed to have moveable compounds\"\n\n        self._world = world\n        self._drop = gamedict['dropper']\n        self._goalrange = gamedict['goal']\n\n        toolspan_min = min(v[0] for v in self._drop)\n        toolspan_max = max(v[0] for v in self._drop)\n        realrange = [gamedict['droprange'][0] + toolspan_min,\n                     gamedict['droprange'][1] + toolspan_max]\n        self._droprange = gamedict['droprange']\n        self._block_droprange = realrange # for putting up blockers\n        self._dim = self._world['dims']\n        self._maxt = max_time\n\n        self._record_ts = record_timestep\n        self._world_ts = world_timestep\n\n        # Add the goal along the floor\n        dimx = self._world['dims'][0]\n        self._world['objects']['FloorGoal'] = {\n            \"type\": \"Goal\",\n            \"color\": \"none\",\n            \"density\": 0,\n            \"vertices\": [\n                [0,0], [0,5], [dimx, 5], [dimx, 0]\n            ]\n        }\n        self._world['gcond'] = {\n            \"type\": \"SpecificInGoal\",\n            \"goal\": \"FloorGoal\",\n            \"obj\": \"GoalBall\",\n            \"duration\": 0.0\n        }\n        # Add blockers\n        if self._block_droprange[0] &gt; 0:\n            self._world['blocks']['lblock'] = {\n                \"color\": \"grey\",\n                \"vertices\": [[0, 0], [0, self._dim[1]],\n                             [self._block_droprange[0], self._dim[1]],\n                             [self._block_droprange[0], 0]]\n            }\n        if self._block_droprange[1] &lt; self._dim[0]:\n            self._world['blocks']['rblock'] = {\n                \"color\": \"grey\",\n                \"vertices\": [[self._block_droprange[1], 0],\n                             [self._block_droprange[1], self._dim[1]],\n                             self._dim,\n                             [self._dim[1], 0]]\n            }\n\n        self._runner = JSRunner()\n        self._checker = CollisionChecker(self._world)\n\n        self._raw_pygw = loadFromDict(self._world)\n        # I'm gonna assume placing at y=550 in the midpoint of the range is\n        # okay...\n        self._place_pygw = loadFromDict(self.make_placed_world(\n            [sum(self._droprange)/2,550]))\n\n\n    \"\"\"Runs the world and returns trajectories and outcomes from a single\n    placement\n\n    Args:\n        position [x,y]: the position to place the dropper at\n\n    Returns:\n        A list of an outcome boolean if the goal has been hit, and a dictionary\n        with all dynamic object trajectories &amp; rotations. If the placement is\n        illegal, just returns None, None\n    \"\"\"\n    def run_placement(self, position):\n        w = self.make_placed_world(position)\n        if w is None:\n            return None, None\n\n        traj, ret, tm = self._runner.run_gw_path_and_rot(w, self._maxt,\n                                                         self._record_ts)\n\n        # Have to manually check for success... goal object as stands just\n        # ends the trajectory\n        gb_endpos = traj['GoalBall'][0][-1]\n        success = self._goalrange[0] &lt;= gb_endpos[0] &lt;= self._goalrange[1]\n        return success, traj\n\n    \"\"\"Makes a new world dictionary with the dropper placed in it\n\n    Args:\n        position [x,y]: the position to place the dropper at\n        skipcheck [bool]: skip the check that you can place the tool? This\n            is required because the check doesn't play nicely with Torch\n\n    Returns:\n        A dict object formatted to be run through JSRunner or translated into\n        the lcp_physics engine\n    \"\"\"\n    def make_placed_world(self, position):\n        newworld = copy.deepcopy(self._world)\n        # Add the dropped object\n        drop = self._make_dropper(position)\n        if drop is None:\n            return None\n        newworld['objects']['PLACED'] = drop\n        return newworld\n\n    \"\"\"Checks whether this is a valid placement\n\n    Args:\n        position [x,y]: the dropper placement to check\n\n    Returns:\n        Boolean indicating if this is okay\n    \"\"\"\n    def check_valid_placement(self, position):\n        if position[0] &lt; 0 or position[0] &gt; self._world['dims'][0] or \\\n             position[1] &lt; 0 or position[1] &gt; self._world['dims'][1]:\n           return False\n        return not self._checker([self._drop], position)\n\n    \"\"\"Draws the initial state of the world\n\n    Args:\n        None\n\n    Returns:\n        A pygame.Surface object with the initial game image\n    \"\"\"\n    def draw(self):\n        # Have to reset the world...\n        sc = drawWorld(self._raw_pygw)\n        self._draw_goalbox(sc)\n        return sc\n\n    \"\"\"Helper to draw the goalbox on the screen\"\"\"\n    def _draw_goalbox(self, screen):\n        gbox = [[self._goalrange[0], self._dim[1]],\n                [self._goalrange[0], self._dim[1]-5],\n                [self._goalrange[1], self._dim[1]-5],\n                [self._goalrange[1], self._dim[1]]]\n        pg.draw.polygon(screen, (0,255,0), gbox)\n\n    \"\"\"Draws the world with dynamic objects given a certain position\n\n    Args:\n        trajectory [dict]: a set of object position/rotations as given by the\n            output of runPlacement[1]\n        time [float]: the time in that trajectory to draw\n\n    Returns:\n        A pygame.Surface with the image of the world in that state\n    \"\"\"\n    def draw_by_position(self, trajectory, time):\n        idx = self._time_to_pos_idx(time)\n        nsteps = len(list(trajectory.values())[0][0])\n        assert 0 &lt;= idx &lt; nsteps, \"Time input out of bounds\"\n        return self._draw_by_index(trajectory, idx)\n\n    \"\"\"As above, but uses indices privately\"\"\"\n    def _draw_by_index(self, trajectory, index):\n        for onm, traj in trajectory.items():\n            assert onm in self._place_pygw.objects.keys(),\\\n                \"Object name not found: \" + onm\n            obj = self._place_pygw.objects[onm]\n            assert not obj.isStatic(), onm + \" is not static!\"\n            pos = traj[0][index]\n            rot = traj[1][index]\n            obj.position = pos\n            obj.rotation = rot\n        sc = drawWorld(self._place_pygw)\n        self._draw_goalbox(sc)\n        return sc\n\n    \"\"\"Makes a movie of the outcome of a given placement\n\n    Args:\n        position [x,y]: the position to place the dropper at\n        movie_screen [pygame.Surface]: the display screen to write to; if\n            None, just writes to files\n        output_dir [string]: a path to a directory where the movie images\n            are written to individually (optional - can be None)\n        return_screens [bool]: should this function return all of the\n            pg.Surface objects it makes?\n    \"\"\"\n    def make_placement_movie(self, position, movie_screen=None,\n                             output_dir=None, return_screens=False):\n        assert movie_screen is not None or output_dir is not None or return_screens,\\\n            \"No display or place to write!\"\n        screens = []\n        succ, traj = self.run_placement(position)\n        assert traj is not None, \"Illegal placement -- no trajectory\"\n        hz = 1 / self._record_ts\n        nsteps = len(list(traj.values())[0][0])\n        if movie_screen is not None:\n            clk = pg.time.Clock()\n        if output_dir is not None:\n            if not os.path.exists(output_dir):\n                os.mkdir(output_dir)\n            odmask = os.path.join(output_dir, \"img_{0:05d}.png\")\n\n        for idx in range(nsteps):\n            draw_screen = self._draw_by_index(traj, idx)\n            screens.append(draw_screen)\n            if movie_screen is not None:\n                pg.event.pump()\n                movie_screen.blit(draw_screen, (0, 0))\n                pg.display.flip()\n                clk.tick(hz)\n            if output_dir is not None:\n                pg.image.save(draw_screen, odmask.format(idx))\n        if return_screens:\n            return succ, traj, screens\n\n\n    \"\"\"Expose the world dictionary\"\"\"\n    def _get_world(self):\n        return self._world\n    world = property(_get_world)\n\n    \"\"\"Expose the dropper\"\"\"\n    def _get_dropper(self):\n        return self._drop\n    dropper = property(_get_dropper)\n\n    \"\"\"Expose the droprange\"\"\"\n    def _get_droprange(self):\n        return self._droprange\n    droprange = property(_get_droprange)\n\n    \"\"\"Expose the goal extent\"\"\"\n    def _get_goal(self):\n        return self._goalrange\n    goal = property(_get_goal)\n\n    \"\"\"Helper so functions can take in time, return an index within a position\n    vector\"\"\"\n    def _time_to_pos_idx(self, time):\n        rough_idx = time / self._record_ts\n        idx = int(round(rough_idx,0))\n        assert abs(idx-rough_idx) &lt; (self._record_ts / 1000.),\\\n            \"Time not found in positions index... ensure divisibility!\"\n        return idx\n\n    \"\"\"Helper to place the dropper\"\"\"\n    def _make_dropper(self, position):\n        # Make sure the position is allowed\n        if not (self._droprange[0] &lt;= position[0] and\\\n                    position[0] &lt;= self._droprange[1]) or\\\n                self._checker(self._drop, position):\n            return None\n        newverts = [[position[0] + v[0], position[1] + v[1]]\n                    for v in self._drop]\n        return {\n            \"type\": \"Poly\",\n            \"color\": \"blue\",\n            \"density\": 1,\n            \"vertices\": newverts\n        }\n</code></pre>"},{"location":"reference/virtualtools/interfaces/simpledropper/#virtualtools.interfaces.simpledropper.SimpleDropper.dropper","title":"<code>dropper = property(_get_dropper)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expose the droprange</p>"},{"location":"reference/virtualtools/interfaces/simpledropper/#virtualtools.interfaces.simpledropper.SimpleDropper.droprange","title":"<code>droprange = property(_get_droprange)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expose the goal extent</p>"},{"location":"reference/virtualtools/interfaces/simpledropper/#virtualtools.interfaces.simpledropper.SimpleDropper.goal","title":"<code>goal = property(_get_goal)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Helper so functions can take in time, return an index within a position vector</p>"},{"location":"reference/virtualtools/interfaces/simpledropper/#virtualtools.interfaces.simpledropper.SimpleDropper.world","title":"<code>world = property(_get_world)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expose the dropper</p>"},{"location":"reference/virtualtools/interfaces/toolpicker/","title":"toolpicker","text":""},{"location":"reference/virtualtools/interfaces/vertexdrawer/","title":"vertexdrawer","text":""},{"location":"reference/virtualtools/interfaces/vtinterface/","title":"vtinterface","text":""},{"location":"reference/virtualtools/vtviewer/","title":"vtviewer","text":""},{"location":"reference/virtualtools/vtviewer/interfaces/","title":"interfaces","text":""},{"location":"reference/virtualtools/vtviewer/movies/","title":"movies","text":""},{"location":"reference/virtualtools/vtviewer/visualization/","title":"visualization","text":""},{"location":"reference/virtualtools/vtviewer/visualize_likelihoods/","title":"visualize_likelihoods","text":""},{"location":"reference/virtualtools/vtviewer/visualize_likelihoods/#virtualtools.vtviewer.visualize_likelihoods.find_bayesopt_functions","title":"<code>find_bayesopt_functions(tp, dat)</code>","text":"<p>Produces likelihood functions for each trial</p>"},{"location":"reference/virtualtools/vtviewer/visualize_likelihoods/#virtualtools.vtviewer.visualize_likelihoods.find_bayesopt_functions--parameters","title":"Parameters","text":"<p>model_data : dict     Output of extract_data data_group : hdf5.group     Group where data is located</p>"},{"location":"reference/virtualtools/vtviewer/visualize_likelihoods/#virtualtools.vtviewer.visualize_likelihoods.find_bayesopt_functions--returns","title":"Returns","text":"<p>A dict with each trial name with elements that are likelihood functions</p> Source code in <code>virtualtools/vtviewer/visualize_likelihoods.py</code> <pre><code>def find_bayesopt_functions(tp, dat):\n    \"\"\"\n    Produces likelihood functions for each trial\n\n    Parameters\n    ----------\n    model_data : dict\n        Output of extract_data\n    data_group : hdf5.group\n        Group where data is located\n\n    Returns\n    -------\n    A dict with each trial name with elements that are likelihood functions\n    \"\"\"\n    fncs = make_bayesopt_distribution(tp, dat['world'], dat['domain'], dat['kernel'], dat['obj_func_creator'], \n            dat['bo_data'], dat['obj_data'], dat['data'], dat['X_step'], dat['Y_step'])\n    return fncs\n</code></pre>"},{"location":"reference/virtualtools/vtviewer/visualize_likelihoods/#virtualtools.vtviewer.visualize_likelihoods.make_single_llh_field","title":"<code>make_single_llh_field(llh_fnc, tool, dim_size)</code>","text":"<p>Makes a small pygame surface with likelihood for one tool</p>"},{"location":"reference/virtualtools/vtviewer/visualize_likelihoods/#virtualtools.vtviewer.visualize_likelihoods.make_single_llh_field--parameters","title":"Parameters","text":"<p>llh_fnc : function     A likelihood function tool : string     The tool name dim_size : int     Size of surface dimensions (smaller for interpolation)</p>"},{"location":"reference/virtualtools/vtviewer/visualize_likelihoods/#virtualtools.vtviewer.visualize_likelihoods.make_single_llh_field--returns","title":"Returns","text":"<p>A pygame.Surface of size (dim_size, dim_size) with just the likelihood field (no level information)</p> Source code in <code>virtualtools/vtviewer/visualize_likelihoods.py</code> <pre><code>def make_single_llh_field(llh_fnc, tool, dim_size):\n    \"\"\"\n    Makes a small pygame surface with likelihood for one tool\n\n    Parameters\n    ----------\n    llh_fnc : function\n        A likelihood function\n    tool : string\n        The tool name\n    dim_size : int\n        Size of surface dimensions (smaller for interpolation)\n\n    Returns\n    -------\n    A pygame.Surface of size (dim_size, dim_size) with just the likelihood\n    field (no level information)\n    \"\"\"\n    px_per = 600 / dim_size / 2\n    pts_raw = np.linspace(0, 600, dim_size, False) + px_per\n    pts = [int(p) for p in pts_raw]\n\n    s = pg.Surface((dim_size, dim_size)).convert_alpha()\n    s.fill((0,0,0,0))\n    for i, x in enumerate(pts):\n        for j, y in enumerate(pts):\n            llh = llh_fnc((tool, (x,y)))\n            #lh = np.exp(llh)\n            s.set_at((i, dim_size-j), llh2col(llh,tool))\n    return s\n</code></pre>"},{"location":"reference/virtualtools/vtviewer/visualize_likelihoods/#virtualtools.vtviewer.visualize_likelihoods.make_trial_llh_img","title":"<code>make_trial_llh_img(tp, llh_fnc, tool_separate=False, dim_size=60)</code>","text":"<p>Makes a pygame surface</p>"},{"location":"reference/virtualtools/vtviewer/visualize_likelihoods/#virtualtools.vtviewer.visualize_likelihoods.make_trial_llh_img--parameters","title":"Parameters","text":"<p>tp : ToolPicker     The toolpicker object llh_fnc : function     The likelihood function empdat : dict     Empirical data from load_singledrop_empirical dim_size : int     Size of surface dimensions for creating the llh fields</p>"},{"location":"reference/virtualtools/vtviewer/visualize_likelihoods/#virtualtools.vtviewer.visualize_likelihoods.make_trial_llh_img--returns","title":"Returns","text":"<p>Three pygame.Surface objects (one for each tool)</p> Source code in <code>virtualtools/vtviewer/visualize_likelihoods.py</code> <pre><code>def make_trial_llh_img(tp, llh_fnc, tool_separate=False, dim_size=60):\n    \"\"\"\n    Makes a pygame surface\n\n    Parameters\n    ----------\n    tp : ToolPicker\n        The toolpicker object\n    llh_fnc : function\n        The likelihood function\n    empdat : dict\n        Empirical data from load_singledrop_empirical\n    dim_size : int\n        Size of surface dimensions for creating the llh fields\n\n    Returns\n    -------\n    Three pygame.Surface objects (one for each tool)\n    \"\"\"\n    r = []\n    world = tp.world\n    def makept(p):\n        return [int(i) for i in world._invert(p)]\n\n    for tool in tp.toolNames:\n        s_sm = make_single_llh_field(llh_fnc, tool, dim_size)\n        s = pg.transform.smoothscale(s_sm, (600, 600))\n        baseC = COLORDICT[tool]\n        if tool_separate:\n            for b in world.blockers.values():\n                drawpts = [makept(p) for p in b.vertices]\n                pg.draw.polygon(s, b.color, drawpts)\n\n            for o in world.objects.values():\n                _draw_obj(o, s, makept)\n\n        r.append(s)\n    if not tool_separate:\n        for b in world.blockers.values():\n            drawpts = [makept(p) for p in b.vertices]\n            pg.draw.polygon(s, b.color, drawpts)\n\n        for o in world.objects.values():\n            _draw_obj(o, s, makept)\n\n        for etool, epos in empdat:\n            baseC = COLORDICT[etool]\n            pg.draw.circle(r[-1],(0,0,0,255),makept(epos),3+2)\n            pg.draw.circle(r[-1], (baseC[0], baseC[1], baseC[2]), makept(epos), 3) \n    return r\n</code></pre>"},{"location":"reference/virtualtools/world/","title":"world","text":""},{"location":"reference/virtualtools/world/abstracts/","title":"abstracts","text":""},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTCond_Base","title":"<code>VTCond_Base</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>class VTCond_Base(ABC):\n\n    def __init__(self):\n        \"\"\"Abstract initialization of a win condition. Should never be called directly; only inherited\n        \"\"\"        \n        self.goal = self.obj = self.parent = self.dur = None\n\n    def _get_time_in(self):\n        return -1\n\n    def remaining_time(self) -&gt; float:\n        \"\"\"Returns the time left until the victory condition is met. If the countdown hasn't yet started, this will be None\n\n        Returns:\n            float: the time remaining (or None)\n        \"\"\"        \n        ti = self._get_time_in()\n        if ti == -1:\n            return None\n        curtime = self.parent.time - ti\n        return max(self.dur - curtime, 0)\n\n    def is_won(self) -&gt; bool:\n        \"\"\"Returns whether the victory condition has been met already\n\n        Returns:\n            bool: True if there is a win, False otherwise\n        \"\"\"        \n        return self.remaining_time() == 0\n\n    @abstractmethod\n    def attach_hooks(self):\n        \"\"\"An abstract method that *must* be overwritten that hooks into the parent World object to set up when the Victory Condition should be called/checked\n\n        Raises:\n            NotImplementedError: always; must be inherited\n        \"\"\"        \n        raise NotImplementedError(\"Cannot attach hooks from base condition object\")\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTCond_Base.__init__","title":"<code>__init__()</code>","text":"<p>Abstract initialization of a win condition. Should never be called directly; only inherited</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def __init__(self):\n    \"\"\"Abstract initialization of a win condition. Should never be called directly; only inherited\n    \"\"\"        \n    self.goal = self.obj = self.parent = self.dur = None\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTCond_Base.attach_hooks","title":"<code>attach_hooks()</code>  <code>abstractmethod</code>","text":"<p>An abstract method that must be overwritten that hooks into the parent World object to set up when the Victory Condition should be called/checked</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>always; must be inherited</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>@abstractmethod\ndef attach_hooks(self):\n    \"\"\"An abstract method that *must* be overwritten that hooks into the parent World object to set up when the Victory Condition should be called/checked\n\n    Raises:\n        NotImplementedError: always; must be inherited\n    \"\"\"        \n    raise NotImplementedError(\"Cannot attach hooks from base condition object\")\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTCond_Base.is_won","title":"<code>is_won()</code>","text":"<p>Returns whether the victory condition has been met already</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if there is a win, False otherwise</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def is_won(self) -&gt; bool:\n    \"\"\"Returns whether the victory condition has been met already\n\n    Returns:\n        bool: True if there is a win, False otherwise\n    \"\"\"        \n    return self.remaining_time() == 0\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTCond_Base.remaining_time","title":"<code>remaining_time()</code>","text":"<p>Returns the time left until the victory condition is met. If the countdown hasn't yet started, this will be None</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the time remaining (or None)</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def remaining_time(self) -&gt; float:\n    \"\"\"Returns the time left until the victory condition is met. If the countdown hasn't yet started, this will be None\n\n    Returns:\n        float: the time remaining (or None)\n    \"\"\"        \n    ti = self._get_time_in()\n    if ti == -1:\n        return None\n    curtime = self.parent.time - ti\n    return max(self.dur - curtime, 0)\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject","title":"<code>VTObject</code>","text":"<p>             Bases: <code>ABC</code></p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>class VTObject(ABC):\n\n    def __init__(self, name: str, otype: str, space: pm.Space, color: str, density: float, friction: float, elasticity: float):\n        \"\"\"Abstract object initialization. This should never be called directly, only from child classes\n\n        Args:\n            name (str): The name flag for the object\n            otype (str): The object type definition\n            space (pm.Space): The pymunk space the object will be added to\n            color (str): A word describing the object color (['blue', 'red', 'green', 'black', 'white', 'grey', 'gray', 'lightgrey', 'none'])\n            density (float): The density of the object. Set to 0 to make this static\n            friction (float): The friction of the object. Must be greater than 0\n            elasticity (float): The elasticity of the object. Must be greater than 0; should be less than 1 or non-physical stuff can happen\n\n        Raises:\n            AssertionError: if the otype argument is not one of the defined - ['Ball','Poly','Segment','Container', 'Compound','Goal','Blocker']\n        \"\"\"        \n        assert otype in ['Ball','Poly','Segment','Container', 'Compound','Goal','Blocker'], \\\n            \"Illegal 'type' of object\"\n        from ..helpers.misc import word_to_color\n        self.name = name\n        self.type = otype\n        self.space = space\n        self.color = word_to_color(color)\n        self.density = density\n        self._cpBody = None\n        self._cpShape = None\n\n    def is_static(self) -&gt; bool:\n        \"\"\"Returns true if the object is static (density==0)\n\n        Returns:\n            bool: a flag if the object is static\n        \"\"\"        \n        return self._cpBody is None\n\n    def get_pos(self):\n        \"\"\"Gets the position of an object\n\n        Returns:\n            numpy.array: An array containing the [x,y] position of the object\n\n        Raises:\n            AssertionError -- if called on a static object\n        \"\"\"        \n        assert not self.is_static(), \"Static bodies do not have a position\"\n        p = self._cpBody.position\n        return np.array([p.x, p.y])\n\n    def set_pos(self, p: Tuple[float, float]):\n        \"\"\"Sets the position of an object. Throws an error if the object is static\n\n        Args:\n            p (Tuple[float, float]): A tuple or list of length 2 defining the [x,y] coordinates to move to\n\n        Raises:\n            AssertionError: if called on a static or if p has a length other than 2\n        \"\"\"\n        assert not self.is_static(), \"Static bodies do not have a position\"\n        assert len(p) == 2, \"Setting position requires vector of length 2\"\n        self._cpBody.position = pm.Vec2d(p[0], p[1])\n\n    def get_vel(self):\n        \"\"\"Gets the velocity of an object\n\n        Returns:\n            numpy.array: An array containing the [x,y] velocity of the object as world units/s\n\n        Raises:\n            AssertionError: if called on a static\n        \"\"\"              \n        assert not self.is_static(), \"Static bodies do not have a velocity\"\n        v = self._cpBody.velocity\n        return np.array([v.x, v.y])\n\n    def set_vel(self, v: Tuple[float, float]):\n        \"\"\"Sets the velocity of an object\n\n        Raises:\n            AssertionError: if called on a static or if v has a length other than 2\n\n        Args:\n            v (Tuple[float, float]): the (x,y) velocity in units/s to set\n        \"\"\"        \n        assert not self.is_static(), \"Static bodies do not have a velocity\"\n        assert len(v) == 2, \"Setting position requires vector of length 2\"\n        self._cpBody.velocity = pm.Vec2d(v[0], v[1])\n\n    def get_rot(self) -&gt; float:\n        \"\"\"Returns the angle of rotation of the object\n\n        Raises:\n            AssertionError: if called on a static\n\n        Returns:\n            float: the angle of rotation in radians\n        \"\"\"        \n        assert not self.is_static(), \"Static bodies do not have a rotation\"\n        return self._cpBody.angle\n\n    def set_rot(self, a: float):\n        \"\"\"Sets the angle of rotation of the object\n\n        Raises:\n            AssertionError: if called on a static\n\n        Args:\n            a (float): the angle of rotation in radians\n        \"\"\"        \n        assert not self.is_static(), \"Static bodies do not have a rotation\"\n        self._cpBody.angle = a\n\n    def get_mass(self) -&gt; float:\n        \"\"\"Returns the mass of the object\n\n        Returns:\n            float: the mass of the object. This is 0 if the object is static\n        \"\"\"        \n        if self.is_static():\n            return 0\n        else:\n            return self._cpBody.mass\n\n    def _expose_shapes(self):\n        return [self._cpShape]\n\n    def check_contact(self, object) -&gt; bool:\n        \"\"\"Checks for contact between this and another object\n\n        Args:\n            object (VTObject): the other object that might contact this one\n\n        Returns:\n            bool: returns true if the objects are overlapping, false otherwise\n        \"\"\"        \n        for myshapes in self._expose_shapes():\n            for oshapes in object._expose_shapes():\n                if len(myshapes.shapes_collide(oshapes).points) &gt; 0:\n                    return True\n        return False\n\n    def set_mass(self, val: float):\n        \"\"\"Sets the mass of an object\n\n        Raises:\n            AssertionError: if called on a static, or if mass is set to a negative value\n\n        Args:\n            val (float): the mass of the object\n        \"\"\"        \n        assert val &gt; 0, \"Must set a positive mass value\"\n        assert not self.is_static(), \"Cannot set the mass of a static object\"\n        self._cpBody.mass = val\n\n    def get_friction(self) -&gt; float:\n        \"\"\"Returns the friction of the object\n\n        Raises:\n            AssertionError: if no shape has been assigned to the object\n\n        Returns:\n            float: the friction\n        \"\"\"        \n        assert self._cpShape is not None, \"Shape not yet set\"\n        return self._cpShape.friction\n\n    def set_friction(self, val: float):\n        \"\"\"Sets the friction of the object\n\n        Raises:\n            AssertionError: if no shape has been assigned to the object, or friction is set to a negative number\n\n        Args:\n            val (float): the friction\n        \"\"\"        \n        assert self._cpShape is not None, \"Shape not yet set\"\n        assert val &gt;= 0, \"Friction must be greater than or equal to 0\"\n        self._cpShape.friction = val\n\n    def get_elasticity(self) -&gt; float:\n        \"\"\"Returns the elasticity of the object\n\n        Raises:\n            AssertionError: if no shape has been assigned to the object\n\n        Returns:\n            float: the elasticity\n        \"\"\"        \n        assert self._cpShape is not None, \"Shape not yet set\"\n        return self._cpShape.elasticity\n\n    def set_elasticity(self, val: float):\n        \"\"\"Sets the elasticity of an object\n\n        Raises:\n            AssertionError: if no shape has been assigned to the object, or if elasticity is set to a negative number\n\n        Args:\n            val (float): the elasticity\n        \"\"\"        \n        assert self._cpShape is not None, \"Shape not yet set\"\n        assert val &gt;= 0, \"Elasticity must be greater than or equal to 0\"\n        self._cpShape.elasticity = val\n\n    def to_geom(self):\n        \"\"\"Returns serializable descriptions of object geometry\n\n        Returns:\n            for type \"poly\": List[Tuple[float, float]] - a list of the vertices (x,y) of the polygon\n            for type \"ball\": Tuple[Tuple[float, float], float] - the (x,y) position and the radius\n            for type \"container\" or \"compound\": List[List[Tuple[float, float]]] - a list of convex polygons, described as a list of (x,y) vertices\n            otherwise: None\n        \"\"\"        \n        if (self.type == \"Poly\"):\n            return self.get_vertices()\n        elif (self.type == \"Ball\"):\n            return [self.get_pos(), self.get_radius()]\n        elif self.type == \"Container\" or self.type == \"Compound\":\n            return self.get_polys()\n        else:\n            print('not a valid object type')\n            return None\n\n    def kick(self, impulse: Tuple[float, float], position: Tuple[float, float], unsafe: bool = False):\n        \"\"\"Applies an impulse to an object at particular world coordinates. The point of impulse must be set within the object unless `unsafe` is flagged as True\n\n        Args:\n            impulse (Tuple[float, float]): the impulse (mass*velocity) transfer in vector form\n            position (Tuple[float, float]): the position to apply this impulse at\n            unsafe (bool, optional): whether to allow the position to lie outside the object. Defaults to False.\n\n        Raises:\n            AssertionError: if unsafe is set to False, this is raised if the position lies outside of this object; also if this object is static\n        \"\"\"        \n        assert not self.is_static(), \"Cannot kick a static object\"\n        if not unsafe:\n            for s in self._expose_shapes():\n                if not s.point_query(position):\n                    raise AssertionError(\"Must kick an object within the object (or set as unsafe)\")\n        self._cpBody.apply_impulse_at_world_point(impulse, position)\n\n    def distance_from_point(self, point: Tuple[float, float]) -&gt; float:\n        \"\"\"Returns the shortest distance between this object and a point. Will be negative if the point lies in this object\n\n        Args:\n            point (Tuple[float, float]): The (x,y) coordinates of the point\n\n        Returns:\n            float: the distance in world units\n        \"\"\"        \n        d, _ = self._cpShape.point_query(point)\n        return d\n\n    def distance_from_point_XY(self, point: Tuple[float, float]) -&gt; pm.Vec2d:\n        \"\"\"Returns the vector between a point and the nearest point on this object\n\n        Args:\n            point (Tuple[float, float]): the (x,y) coordinates of the point\n\n        Returns:\n            pm.Vec2d: a pymunk Vec2d object describing the vector difference\n        \"\"\"        \n        _, info = self._cpShape.point_query(point)\n        return point - info.point\n\n    # Add pythonic decorators\n    position = property(get_pos, set_pos)\n    velocity = property(get_vel, set_vel)\n    rotation = property(get_rot, set_rot)\n    mass = property(get_mass, set_mass)\n    friction = property(get_friction, set_friction)\n    elasticity = property(get_elasticity, set_elasticity)\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.__init__","title":"<code>__init__(name, otype, space, color, density, friction, elasticity)</code>","text":"<p>Abstract object initialization. This should never be called directly, only from child classes</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name flag for the object</p> required <code>otype</code> <code>str</code> <p>The object type definition</p> required <code>space</code> <code>Space</code> <p>The pymunk space the object will be added to</p> required <code>color</code> <code>str</code> <p>A word describing the object color (['blue', 'red', 'green', 'black', 'white', 'grey', 'gray', 'lightgrey', 'none'])</p> required <code>density</code> <code>float</code> <p>The density of the object. Set to 0 to make this static</p> required <code>friction</code> <code>float</code> <p>The friction of the object. Must be greater than 0</p> required <code>elasticity</code> <code>float</code> <p>The elasticity of the object. Must be greater than 0; should be less than 1 or non-physical stuff can happen</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>if the otype argument is not one of the defined - ['Ball','Poly','Segment','Container', 'Compound','Goal','Blocker']</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def __init__(self, name: str, otype: str, space: pm.Space, color: str, density: float, friction: float, elasticity: float):\n    \"\"\"Abstract object initialization. This should never be called directly, only from child classes\n\n    Args:\n        name (str): The name flag for the object\n        otype (str): The object type definition\n        space (pm.Space): The pymunk space the object will be added to\n        color (str): A word describing the object color (['blue', 'red', 'green', 'black', 'white', 'grey', 'gray', 'lightgrey', 'none'])\n        density (float): The density of the object. Set to 0 to make this static\n        friction (float): The friction of the object. Must be greater than 0\n        elasticity (float): The elasticity of the object. Must be greater than 0; should be less than 1 or non-physical stuff can happen\n\n    Raises:\n        AssertionError: if the otype argument is not one of the defined - ['Ball','Poly','Segment','Container', 'Compound','Goal','Blocker']\n    \"\"\"        \n    assert otype in ['Ball','Poly','Segment','Container', 'Compound','Goal','Blocker'], \\\n        \"Illegal 'type' of object\"\n    from ..helpers.misc import word_to_color\n    self.name = name\n    self.type = otype\n    self.space = space\n    self.color = word_to_color(color)\n    self.density = density\n    self._cpBody = None\n    self._cpShape = None\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.check_contact","title":"<code>check_contact(object)</code>","text":"<p>Checks for contact between this and another object</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <code>VTObject</code> <p>the other object that might contact this one</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>returns true if the objects are overlapping, false otherwise</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def check_contact(self, object) -&gt; bool:\n    \"\"\"Checks for contact between this and another object\n\n    Args:\n        object (VTObject): the other object that might contact this one\n\n    Returns:\n        bool: returns true if the objects are overlapping, false otherwise\n    \"\"\"        \n    for myshapes in self._expose_shapes():\n        for oshapes in object._expose_shapes():\n            if len(myshapes.shapes_collide(oshapes).points) &gt; 0:\n                return True\n    return False\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.distance_from_point","title":"<code>distance_from_point(point)</code>","text":"<p>Returns the shortest distance between this object and a point. Will be negative if the point lies in this object</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Tuple[float, float]</code> <p>The (x,y) coordinates of the point</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the distance in world units</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def distance_from_point(self, point: Tuple[float, float]) -&gt; float:\n    \"\"\"Returns the shortest distance between this object and a point. Will be negative if the point lies in this object\n\n    Args:\n        point (Tuple[float, float]): The (x,y) coordinates of the point\n\n    Returns:\n        float: the distance in world units\n    \"\"\"        \n    d, _ = self._cpShape.point_query(point)\n    return d\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.distance_from_point_XY","title":"<code>distance_from_point_XY(point)</code>","text":"<p>Returns the vector between a point and the nearest point on this object</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Tuple[float, float]</code> <p>the (x,y) coordinates of the point</p> required <p>Returns:</p> Type Description <code>Vec2d</code> <p>pm.Vec2d: a pymunk Vec2d object describing the vector difference</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def distance_from_point_XY(self, point: Tuple[float, float]) -&gt; pm.Vec2d:\n    \"\"\"Returns the vector between a point and the nearest point on this object\n\n    Args:\n        point (Tuple[float, float]): the (x,y) coordinates of the point\n\n    Returns:\n        pm.Vec2d: a pymunk Vec2d object describing the vector difference\n    \"\"\"        \n    _, info = self._cpShape.point_query(point)\n    return point - info.point\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.get_elasticity","title":"<code>get_elasticity()</code>","text":"<p>Returns the elasticity of the object</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if no shape has been assigned to the object</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the elasticity</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def get_elasticity(self) -&gt; float:\n    \"\"\"Returns the elasticity of the object\n\n    Raises:\n        AssertionError: if no shape has been assigned to the object\n\n    Returns:\n        float: the elasticity\n    \"\"\"        \n    assert self._cpShape is not None, \"Shape not yet set\"\n    return self._cpShape.elasticity\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.get_friction","title":"<code>get_friction()</code>","text":"<p>Returns the friction of the object</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if no shape has been assigned to the object</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the friction</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def get_friction(self) -&gt; float:\n    \"\"\"Returns the friction of the object\n\n    Raises:\n        AssertionError: if no shape has been assigned to the object\n\n    Returns:\n        float: the friction\n    \"\"\"        \n    assert self._cpShape is not None, \"Shape not yet set\"\n    return self._cpShape.friction\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.get_mass","title":"<code>get_mass()</code>","text":"<p>Returns the mass of the object</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the mass of the object. This is 0 if the object is static</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def get_mass(self) -&gt; float:\n    \"\"\"Returns the mass of the object\n\n    Returns:\n        float: the mass of the object. This is 0 if the object is static\n    \"\"\"        \n    if self.is_static():\n        return 0\n    else:\n        return self._cpBody.mass\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.get_pos","title":"<code>get_pos()</code>","text":"<p>Gets the position of an object</p> <p>Returns:</p> Type Description <p>numpy.array: An array containing the [x,y] position of the object</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def get_pos(self):\n    \"\"\"Gets the position of an object\n\n    Returns:\n        numpy.array: An array containing the [x,y] position of the object\n\n    Raises:\n        AssertionError -- if called on a static object\n    \"\"\"        \n    assert not self.is_static(), \"Static bodies do not have a position\"\n    p = self._cpBody.position\n    return np.array([p.x, p.y])\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.get_rot","title":"<code>get_rot()</code>","text":"<p>Returns the angle of rotation of the object</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if called on a static</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the angle of rotation in radians</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def get_rot(self) -&gt; float:\n    \"\"\"Returns the angle of rotation of the object\n\n    Raises:\n        AssertionError: if called on a static\n\n    Returns:\n        float: the angle of rotation in radians\n    \"\"\"        \n    assert not self.is_static(), \"Static bodies do not have a rotation\"\n    return self._cpBody.angle\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.get_vel","title":"<code>get_vel()</code>","text":"<p>Gets the velocity of an object</p> <p>Returns:</p> Type Description <p>numpy.array: An array containing the [x,y] velocity of the object as world units/s</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if called on a static</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def get_vel(self):\n    \"\"\"Gets the velocity of an object\n\n    Returns:\n        numpy.array: An array containing the [x,y] velocity of the object as world units/s\n\n    Raises:\n        AssertionError: if called on a static\n    \"\"\"              \n    assert not self.is_static(), \"Static bodies do not have a velocity\"\n    v = self._cpBody.velocity\n    return np.array([v.x, v.y])\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.is_static","title":"<code>is_static()</code>","text":"<p>Returns true if the object is static (density==0)</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>a flag if the object is static</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def is_static(self) -&gt; bool:\n    \"\"\"Returns true if the object is static (density==0)\n\n    Returns:\n        bool: a flag if the object is static\n    \"\"\"        \n    return self._cpBody is None\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.kick","title":"<code>kick(impulse, position, unsafe=False)</code>","text":"<p>Applies an impulse to an object at particular world coordinates. The point of impulse must be set within the object unless <code>unsafe</code> is flagged as True</p> <p>Parameters:</p> Name Type Description Default <code>impulse</code> <code>Tuple[float, float]</code> <p>the impulse (mass*velocity) transfer in vector form</p> required <code>position</code> <code>Tuple[float, float]</code> <p>the position to apply this impulse at</p> required <code>unsafe</code> <code>bool</code> <p>whether to allow the position to lie outside the object. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if unsafe is set to False, this is raised if the position lies outside of this object; also if this object is static</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def kick(self, impulse: Tuple[float, float], position: Tuple[float, float], unsafe: bool = False):\n    \"\"\"Applies an impulse to an object at particular world coordinates. The point of impulse must be set within the object unless `unsafe` is flagged as True\n\n    Args:\n        impulse (Tuple[float, float]): the impulse (mass*velocity) transfer in vector form\n        position (Tuple[float, float]): the position to apply this impulse at\n        unsafe (bool, optional): whether to allow the position to lie outside the object. Defaults to False.\n\n    Raises:\n        AssertionError: if unsafe is set to False, this is raised if the position lies outside of this object; also if this object is static\n    \"\"\"        \n    assert not self.is_static(), \"Cannot kick a static object\"\n    if not unsafe:\n        for s in self._expose_shapes():\n            if not s.point_query(position):\n                raise AssertionError(\"Must kick an object within the object (or set as unsafe)\")\n    self._cpBody.apply_impulse_at_world_point(impulse, position)\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.set_elasticity","title":"<code>set_elasticity(val)</code>","text":"<p>Sets the elasticity of an object</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if no shape has been assigned to the object, or if elasticity is set to a negative number</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float</code> <p>the elasticity</p> required Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def set_elasticity(self, val: float):\n    \"\"\"Sets the elasticity of an object\n\n    Raises:\n        AssertionError: if no shape has been assigned to the object, or if elasticity is set to a negative number\n\n    Args:\n        val (float): the elasticity\n    \"\"\"        \n    assert self._cpShape is not None, \"Shape not yet set\"\n    assert val &gt;= 0, \"Elasticity must be greater than or equal to 0\"\n    self._cpShape.elasticity = val\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.set_friction","title":"<code>set_friction(val)</code>","text":"<p>Sets the friction of the object</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if no shape has been assigned to the object, or friction is set to a negative number</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float</code> <p>the friction</p> required Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def set_friction(self, val: float):\n    \"\"\"Sets the friction of the object\n\n    Raises:\n        AssertionError: if no shape has been assigned to the object, or friction is set to a negative number\n\n    Args:\n        val (float): the friction\n    \"\"\"        \n    assert self._cpShape is not None, \"Shape not yet set\"\n    assert val &gt;= 0, \"Friction must be greater than or equal to 0\"\n    self._cpShape.friction = val\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.set_mass","title":"<code>set_mass(val)</code>","text":"<p>Sets the mass of an object</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if called on a static, or if mass is set to a negative value</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float</code> <p>the mass of the object</p> required Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def set_mass(self, val: float):\n    \"\"\"Sets the mass of an object\n\n    Raises:\n        AssertionError: if called on a static, or if mass is set to a negative value\n\n    Args:\n        val (float): the mass of the object\n    \"\"\"        \n    assert val &gt; 0, \"Must set a positive mass value\"\n    assert not self.is_static(), \"Cannot set the mass of a static object\"\n    self._cpBody.mass = val\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.set_pos","title":"<code>set_pos(p)</code>","text":"<p>Sets the position of an object. Throws an error if the object is static</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Tuple[float, float]</code> <p>A tuple or list of length 2 defining the [x,y] coordinates to move to</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>if called on a static or if p has a length other than 2</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def set_pos(self, p: Tuple[float, float]):\n    \"\"\"Sets the position of an object. Throws an error if the object is static\n\n    Args:\n        p (Tuple[float, float]): A tuple or list of length 2 defining the [x,y] coordinates to move to\n\n    Raises:\n        AssertionError: if called on a static or if p has a length other than 2\n    \"\"\"\n    assert not self.is_static(), \"Static bodies do not have a position\"\n    assert len(p) == 2, \"Setting position requires vector of length 2\"\n    self._cpBody.position = pm.Vec2d(p[0], p[1])\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.set_rot","title":"<code>set_rot(a)</code>","text":"<p>Sets the angle of rotation of the object</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if called on a static</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>the angle of rotation in radians</p> required Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def set_rot(self, a: float):\n    \"\"\"Sets the angle of rotation of the object\n\n    Raises:\n        AssertionError: if called on a static\n\n    Args:\n        a (float): the angle of rotation in radians\n    \"\"\"        \n    assert not self.is_static(), \"Static bodies do not have a rotation\"\n    self._cpBody.angle = a\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.set_vel","title":"<code>set_vel(v)</code>","text":"<p>Sets the velocity of an object</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if called on a static or if v has a length other than 2</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Tuple[float, float]</code> <p>the (x,y) velocity in units/s to set</p> required Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def set_vel(self, v: Tuple[float, float]):\n    \"\"\"Sets the velocity of an object\n\n    Raises:\n        AssertionError: if called on a static or if v has a length other than 2\n\n    Args:\n        v (Tuple[float, float]): the (x,y) velocity in units/s to set\n    \"\"\"        \n    assert not self.is_static(), \"Static bodies do not have a velocity\"\n    assert len(v) == 2, \"Setting position requires vector of length 2\"\n    self._cpBody.velocity = pm.Vec2d(v[0], v[1])\n</code></pre>"},{"location":"reference/virtualtools/world/abstracts/#virtualtools.world.abstracts.VTObject.to_geom","title":"<code>to_geom()</code>","text":"<p>Returns serializable descriptions of object geometry</p> <p>Returns:</p> Name Type Description <p>for type \"poly\": List[Tuple[float, float]] - a list of the vertices (x,y) of the polygon</p> <p>for type \"ball\": Tuple[Tuple[float, float], float] - the (x,y) position and the radius</p> <p>for type \"container\" or \"compound\": List[List[Tuple[float, float]]] - a list of convex polygons, described as a list of (x,y) vertices</p> <code>otherwise</code> <p>None</p> Source code in <code>virtualtools/world/abstracts.py</code> <pre><code>def to_geom(self):\n    \"\"\"Returns serializable descriptions of object geometry\n\n    Returns:\n        for type \"poly\": List[Tuple[float, float]] - a list of the vertices (x,y) of the polygon\n        for type \"ball\": Tuple[Tuple[float, float], float] - the (x,y) position and the radius\n        for type \"container\" or \"compound\": List[List[Tuple[float, float]]] - a list of convex polygons, described as a list of (x,y) vertices\n        otherwise: None\n    \"\"\"        \n    if (self.type == \"Poly\"):\n        return self.get_vertices()\n    elif (self.type == \"Ball\"):\n        return [self.get_pos(), self.get_radius()]\n    elif self.type == \"Container\" or self.type == \"Compound\":\n        return self.get_polys()\n    else:\n        print('not a valid object type')\n        return None\n</code></pre>"},{"location":"reference/virtualtools/world/conditions/","title":"conditions","text":""},{"location":"reference/virtualtools/world/conditions/#virtualtools.world.conditions.VTCond_AnyInGoal","title":"<code>VTCond_AnyInGoal</code>","text":"<p>             Bases: <code>VTCond_Base</code></p> Source code in <code>virtualtools/world/conditions.py</code> <pre><code>class VTCond_AnyInGoal(VTCond_Base):\n\n    def __init__(self, goalname: str, duration: float, parent, exclusions: List[str] = []):\n        \"\"\"A victory condition if *any* moving object makes it into the goal (except those defined by the exception list)\n\n        Args:\n            goalname (str): the \"name\" flag of the goal\n            duration (float): the amount of time an object must be in the goal to win (in seconds)\n            parent (VTWorld): the VTWorld object this is describing the victory condition for\n            exclusions (List[str], optional): _description_. Defaults to [].\n        \"\"\"        \n        self.type = \"AnyInGoal\"\n        self.won = False\n        self.goal = goalname\n        self.excl = exclusions\n        self.dur = duration\n        self.ins = {}\n        self.has_time = True\n        self.parent = parent\n\n    def _goes_in(self, obj, goal):\n        if (goal.name == self.goal and \\\n                    (not obj.name in self.ins.keys()) and \\\n                    (not obj.name in self.excl)):\n            self.ins[obj.name] = self.parent.time\n\n    def _goes_out(self, obj, goal):\n        if (goal.name == self.goal and \\\n            obj.name in self.ins.keys() and \\\n                    (not goal.point_in(obj.position))):\n            del self.ins[obj.name]\n\n    def attach_hooks(self):\n        \"\"\"Sets collision handlers for victory condition logic\n        \"\"\"        \n        self.parent.set_goal_collision_begin(self._goes_in)\n        self.parent.set_goal_collision_end(self._goes_out)\n\n    def _get_time_in(self):\n        if len(self.ins) == 0:\n            return -1\n        mintime = min(min(self.ins.values()), self.parent.time)\n        return mintime\n</code></pre>"},{"location":"reference/virtualtools/world/conditions/#virtualtools.world.conditions.VTCond_AnyInGoal.__init__","title":"<code>__init__(goalname, duration, parent, exclusions=[])</code>","text":"<p>A victory condition if any moving object makes it into the goal (except those defined by the exception list)</p> <p>Parameters:</p> Name Type Description Default <code>goalname</code> <code>str</code> <p>the \"name\" flag of the goal</p> required <code>duration</code> <code>float</code> <p>the amount of time an object must be in the goal to win (in seconds)</p> required <code>parent</code> <code>VTWorld</code> <p>the VTWorld object this is describing the victory condition for</p> required <code>exclusions</code> <code>List[str]</code> <p>description. Defaults to [].</p> <code>[]</code> Source code in <code>virtualtools/world/conditions.py</code> <pre><code>def __init__(self, goalname: str, duration: float, parent, exclusions: List[str] = []):\n    \"\"\"A victory condition if *any* moving object makes it into the goal (except those defined by the exception list)\n\n    Args:\n        goalname (str): the \"name\" flag of the goal\n        duration (float): the amount of time an object must be in the goal to win (in seconds)\n        parent (VTWorld): the VTWorld object this is describing the victory condition for\n        exclusions (List[str], optional): _description_. Defaults to [].\n    \"\"\"        \n    self.type = \"AnyInGoal\"\n    self.won = False\n    self.goal = goalname\n    self.excl = exclusions\n    self.dur = duration\n    self.ins = {}\n    self.has_time = True\n    self.parent = parent\n</code></pre>"},{"location":"reference/virtualtools/world/conditions/#virtualtools.world.conditions.VTCond_AnyInGoal.attach_hooks","title":"<code>attach_hooks()</code>","text":"<p>Sets collision handlers for victory condition logic</p> Source code in <code>virtualtools/world/conditions.py</code> <pre><code>def attach_hooks(self):\n    \"\"\"Sets collision handlers for victory condition logic\n    \"\"\"        \n    self.parent.set_goal_collision_begin(self._goes_in)\n    self.parent.set_goal_collision_end(self._goes_out)\n</code></pre>"},{"location":"reference/virtualtools/world/constants/","title":"constants","text":""},{"location":"reference/virtualtools/world/noisyworld/","title":"noisyworld","text":""},{"location":"reference/virtualtools/world/noisyworld/#virtualtools.world.noisyworld.noisify_world","title":"<code>noisify_world(gameworld, noise_position_static=0.0, noise_position_moving=0.0, noise_collision_direction=0.0, noise_collision_elasticity=0.0, noise_gravity=0.0, noise_object_friction=0.0, noise_object_density=0.0, noise_object_elasticity=0.0)</code>","text":"<p>Creates a noisy version of a VTWorld, including: perceptual noise, collision noise, and property noise (NOTE: property noise currently is not implemented, except for gravity)</p> perceptual noise <p>Changes the location of objects by perturbing each objects' positions by a gaussian around the original location. The standard deviation of this is set separately for static and moving objects</p> collision noise <p>Noise in the dynamics of the system. This is added uncertainty whenever there is a collision. In pymunk, collisions are resolved by providing equal and opposite impulses at the point of collision; this noise perturbs both the direction and the magnitude of those impulses</p> property noise <p>Currently only provides uncertainty about the gravity of the world; in theory should also add noise to friction, density, and elasticities of each object</p> <p>Parameters:</p> Name Type Description Default <code>gameworld</code> <code>VTWorld</code> <p>the world to make noisy</p> required <code>noise_position_static</code> <code>float</code> <p>the sd of an isotropic gaussian describing perceptual uncertainty for static objects. Defaults to 0..</p> <code>0.0</code> <code>noise_position_moving</code> <code>float</code> <p>the sd of an isotropic gaussian describing perceptual uncertainty for moving objects. Defaults to 0..</p> <code>0.0</code> <code>noise_collision_direction</code> <code>float</code> <p>the sd of a wrapped gaussian describing collision impulse perturbations. Defaults to 0..</p> <code>0.0</code> <code>noise_collision_elasticity</code> <code>float</code> <p>the sd of the elasticity of the colision, which directly impacts the magnitude. Defaults to 0..</p> <code>0.0</code> <code>noise_gravity</code> <code>float</code> <p>the sd of a truncated gaussian centered at 1 which is multiplied by the true gravity (but cannot bring gravity below 0). Defaults to 0..</p> <code>0.0</code> <code>noise_object_friction</code> <code>float</code> <p>NOT IMPLEMENTED. Defaults to 0..</p> <code>0.0</code> <code>noise_object_density</code> <code>float</code> <p>NOT IMPLEMENTED. Defaults to 0..</p> <code>0.0</code> <code>noise_object_elasticity</code> <code>float</code> <p>NOT IMPLEMENTED. Defaults to 0..</p> <code>0.0</code> <p>Returns:</p> Name Type Description <code>VTWorld</code> <code>VTWorld</code> <p>a noisy version of the original world</p> Source code in <code>virtualtools/world/noisyworld.py</code> <pre><code>def noisify_world(gameworld: VTWorld,\n                  noise_position_static: float=0.,\n                  noise_position_moving: float=0.,\n                  noise_collision_direction: float=0.,\n                  noise_collision_elasticity: float=0.,\n                  noise_gravity: float=0.,\n                  noise_object_friction: float=0.,\n                  noise_object_density: float=0.,\n                  noise_object_elasticity: float=0.) -&gt; VTWorld:\n    \"\"\"Creates a noisy version of a VTWorld, including: perceptual noise, collision noise, and property noise\n    (NOTE: property noise currently is not implemented, except for gravity)\n\n    perceptual noise:\n        Changes the location of objects by perturbing each objects' positions by a gaussian around the original location. The standard deviation of this is set separately for static and moving objects\n\n    collision noise:\n        Noise in the dynamics of the system. This is added uncertainty whenever there is a collision. In pymunk, collisions are resolved by providing equal and opposite impulses at the point of collision; this noise perturbs both the direction and the magnitude of those impulses\n\n    property noise:\n        Currently only provides uncertainty about the gravity of the world; in theory should also add noise to friction, density, and elasticities of each object\n\n    Args:\n        gameworld (VTWorld): the world to make noisy\n        noise_position_static (float, optional): the sd of an isotropic gaussian describing perceptual uncertainty for static objects. Defaults to 0..\n        noise_position_moving (float, optional): the sd of an isotropic gaussian describing perceptual uncertainty for moving objects. Defaults to 0..\n        noise_collision_direction (float, optional): the sd of a wrapped gaussian describing collision impulse perturbations. Defaults to 0..\n        noise_collision_elasticity (float, optional): the sd of the elasticity of the colision, which directly impacts the magnitude. Defaults to 0..\n        noise_gravity (float, optional): the sd of a truncated gaussian centered at 1 which is multiplied by the true gravity (but cannot bring gravity below 0). Defaults to 0..\n        noise_object_friction (float, optional): NOT IMPLEMENTED. Defaults to 0..\n        noise_object_density (float, optional): NOT IMPLEMENTED. Defaults to 0..\n        noise_object_elasticity (float, optional): NOT IMPLEMENTED. Defaults to 0..\n\n    Returns:\n        VTWorld: a noisy version of the original world\n    \"\"\"    \n\n    w = gameworld.copy()\n\n    # Figure out the gravity (with adjustments)\n    if noise_gravity &gt; 0:\n        grav = w.gravity * trunc_norm(1, noise_gravity, 0)\n    else:\n        grav = w.gravity\n\n    # Turn things off (gravity &amp; callbacks)\n    w.gravity = 0\n    w._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SOLID)\n    w._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SOLID)\n    w._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SENSOR)\n    w._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SENSOR)\n\n    # Adjust the object positions and attributes\n    # First segment in to static vs not static &amp; adjust properties\n    wall_names = [\"_LeftWall\", \"_BottomWall\", \"_RightWall\", \"_TopWall\"]\n\n    # With static noise, group all touching objects and move them together\n    if noise_position_static &gt; 0:\n        # Make object groups (things that move together because they are touching)\n        obj_groups = []\n        objs = w.objects.values()\n        for i in range(len(objs) - 1):\n            o1 = objs[i]\n            if o1.name not in wall_names:\n                this_idx = -1\n                for idx, og in enumerate(obj_groups):\n                    if o1.name in [o.name for o in og]:\n                        this_idx = idx\n                if this_idx == -1:\n                    this_idx = len(obj_groups)\n                    obj_groups.append([o1])\n                for j in range(i + 1, len(objs)):\n                    o2 = objs[j]\n                    if o1.checkContact(o2):\n                        if o2.name not in [o.name for o in obj_groups[this_idx]] + wall_names:\n                            obj_groups[this_idx].append(o2)\n\n        # Now that the space is segmented, move all static items together\n        for og in obj_groups:\n            pos_change = noise_position_static * norm.rvs(size=2)\n            for o in og:\n                if o.is_static():\n                    _move_static(o, pos_change, w._cpSpace)\n                else:\n                    o.position += pos_change\n\n    # With moving noise, adjust objects individually but make sure they are still touching everything they already were\n    if noise_position_moving &gt; 0:\n        # Find the things that need to be moved and cache their original positions and touching objects\n        free_obj = []\n        orig_pos = {}\n        orig_vel = {}\n        touch_dict = {}\n        for onm, obj in w.objects.items():\n            if not obj.is_static():\n                free_obj.append(obj)\n                orig_pos[onm] = obj.position\n                orig_vel[onm] = obj.velocity\n\n                obj.velocity = (0, 0)\n                touch_dict[onm] = []\n                for onm2, obj2 in w.objects.items():\n                    if onm != onm2:\n                        if obj.checkContact(obj2):\n                            touch_dict[onm].append(obj2)\n\n        # Catch to ensure moving static objects doesn't produce an impossible configuration\n        noise_attempts = 0\n        max_attempts = 500\n        while len(free_obj) &gt; 0 and noise_attempts &lt; max_attempts:\n            noise_attempts += 1\n\n            # Randomly perturb everything\n            for o in free_obj:\n                o.position += noise_position_moving * norm.rvs(size=2)\n\n            # Take tiny steps to resolve overlaps\n            for i in range(10):\n                w._cpSpace.step(.1)\n\n            # Check that any contacts that existed already still remain - if not, reset\n            checked_contacts = []\n            for o in free_obj:\n                stillgood = True\n                touches = touch_dict[o.name]\n                for o2 in w.objects.values():\n                    if stillgood and o.name != o2.name:  # Make sure it's not the same thing; save compuatation\n                        if o.checkContact(o2):\n                            # If there's a contact, make sure that it's not a new one\n                            if o2 not in touches:\n                                stillgood = False\n                        else:\n                            # Otherwise, make sure if it's not touching it shouldn't be\n                            if o2 in touches:\n                                stillgood = False\n                if stillgood:\n                    checked_contacts.append(o.name)\n                    o._cpBody.sleep()\n                else:\n                    o.position = orig_pos[o.name]\n\n            # Now reduce free_obj\n\n            # things are getting messed up when we reduce free_obj in the w._cpSpace.step() phase to not include all objects. I'm not sure why,\n            # but the obvious fix for this for now is to just free up every object whenever we don't \"make it\" through to having no free objects\n            curr_free_obj = [\n                o for o in free_obj if o.name not in checked_contacts]\n            if len(curr_free_obj) &gt; 0:\n                for o in free_obj:\n                    o._cpBody.activate()  # wake things again if this isn't going to work\n            else:\n                free_obj = []\n\n        # Wake things back up\n        for onm, v in orig_vel.items():\n            o = w.objects[onm]\n            o._cpBody.activate()\n            o.velocity = v\n\n        # so as to prevent impossible configurations - just go back to original position\n        if noise_attempts &gt;= max_attempts:\n            for onm, v in orig_vel.items():\n                o = w.objects[onm]\n                o.velocity = v\n                o.position = orig_pos[onm]\n\n    # Set the callbacks to add noise\n    if noise_collision_direction &gt; 0 or noise_collision_elasticity &gt; 0:\n        def noisify_arbiter(arb):\n            # Make the restitution noisy\n            if noise_collision_elasticity &gt; 0:\n                arb.restitution += trunc_norm(0,\n                                              noise_collision_elasticity, -arb.restitution)\n            # Make the contact normals noisy\n            if noise_collision_direction &gt; 0:\n                newnorm = arb.contact_point_set.normal.rotated(\n                    wrapped_norm(0, noise_collision_direction))\n                setpoints = []\n                for cp in arb.contact_point_set.points:\n                    setpoints.append(pm.ContactPoint(\n                        list(cp.point_a), list(cp.point_b), cp.distance))\n                newcps = pm.ContactPointSet(list(newnorm), setpoints)\n                arb.contact_point_set = newcps\n\n        def do_solid_solid_pre(arb, space, data):\n            noisify_arbiter(arb)\n            return w._solid_solid_pre(arb, space, data)\n\n    else:\n        def do_solid_solid_pre(arb, space, data):\n            return w._solid_solid_pre(arb, space, data)\n\n    # Reset the world\n    w.gravity = grav\n\n    def do_solid_solid_begin(arb, space, data):\n        return w._solid_solid_begin(arb, space, data)\n\n    def do_solid_solid_post(arb, space, data):\n        return w._solid_solid_post(arb, space, data)\n\n    def do_solid_solid_end(arb, space, data):\n        return w._solid_solid_end(arb, space, data)\n\n    def do_solid_goal_begin(arb, space, data):\n        return w._solid_goal_begin(arb, space, data)\n\n    def do_solid_goal_end(arb, space, data):\n        return w._solid_goal_end(arb, space, data)\n\n    ssch = w._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SOLID)\n    ssch.begin = do_solid_solid_begin\n    ssch.pre_solve = do_solid_solid_pre\n    ssch.post_solve = do_solid_solid_post\n    ssch.separate = do_solid_solid_end\n\n    psch = w._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SOLID)\n    psch.begin = do_solid_solid_begin\n    psch.pre_solve = do_solid_solid_pre\n    psch.post_solve = do_solid_solid_post\n    psch.separate = do_solid_solid_end\n\n    ssench = w._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SENSOR)\n    ssench.begin = do_solid_goal_begin\n    ssench.separate = do_solid_goal_end\n\n    psench = w._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SENSOR)\n    psench.begin = do_solid_goal_begin\n    psench.separate = do_solid_goal_end\n\n    w._cpSpace.step(.0001)\n    return w\n</code></pre>"},{"location":"reference/virtualtools/world/noisyworld/#virtualtools.world.noisyworld.trunc_norm","title":"<code>trunc_norm(mu, sig, lower=None, upper=None)</code>","text":"<p>Provides a random draw from a truncated normal</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>float</code> <p>the mean of the (untruncated) distribution</p> required <code>sig</code> <code>float</code> <p>the standard deviation of the (untruncated) distribution</p> required <code>lower</code> <code>float</code> <p>the truncation lower bound. Defaults to None, which coerces this to -20</p> <code>None</code> <code>upper</code> <code>float</code> <p>the truncation upper bound. Defaults to None, which coerces this to 20</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>a random number drawn from this distribution</p> Source code in <code>virtualtools/world/noisyworld.py</code> <pre><code>def trunc_norm(mu: float, sig: float,\n               lower: float=None, upper: float=None) -&gt; float:\n    \"\"\"Provides a random draw from a truncated normal\n\n    Args:\n        mu (float): the mean of the (untruncated) distribution\n        sig (float): the standard deviation of the (untruncated) distribution\n        lower (float, optional): the truncation lower bound. Defaults to None, which coerces this to -20\n        upper (float, optional): the truncation upper bound. Defaults to None, which coerces this to 20\n\n    Returns:\n        float: a random number drawn from this distribution\n    \"\"\"    \n    if lower is None:\n        a = -20\n    else:\n        a = (lower - mu) / sig\n    if upper is None:\n        b = 20\n    else:\n        b = (upper - mu) / sig\n    return mu + sig * truncnorm.rvs(a, b, size=1)[0]\n</code></pre>"},{"location":"reference/virtualtools/world/noisyworld/#virtualtools.world.noisyworld.wrapped_norm","title":"<code>wrapped_norm(mu, sig)</code>","text":"<p>Provides a random draw from a wrapped normal (around 2pi radians)</p> <p>Parameters:</p> Name Type Description Default <code>mu</code> <code>float</code> <p>the mean of the (unwrapped) distribution</p> required <code>sig</code> <code>float</code> <p>the standard deviation of the (unwrapped) distribution</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>a random number drawn from this distribution; will be in the range of [0, 2*pi)</p> Source code in <code>virtualtools/world/noisyworld.py</code> <pre><code>def wrapped_norm(mu: float, sig: float) -&gt; float:\n    \"\"\"Provides a random draw from a wrapped normal (around 2pi radians)\n\n    Args:\n        mu (float): the mean of the (unwrapped) distribution\n        sig (float): the standard deviation of the (unwrapped) distribution\n\n    Returns:\n        float: a random number drawn from this distribution; will be in the range of [0, 2*pi)\n    \"\"\"    \n    return (mu + sig * norm.rvs(size=1))[0] % (2 * np.pi)\n</code></pre>"},{"location":"reference/virtualtools/world/object/","title":"object","text":""},{"location":"reference/virtualtools/world/object/#virtualtools.world.object.VTBall","title":"<code>VTBall</code>","text":"<p>             Bases: <code>VTObject</code></p> Source code in <code>virtualtools/world/object.py</code> <pre><code>class VTBall(VTObject):\n\n    def __init__(self, name: str, space: pm.Space, position: Tuple[float, float], radius: float,\n                 density: float = DEFAULT_DENSITY, elasticity: float=DEFAULT_ELASTICITY,\n                 friction: float=DEFAULT_FRICTION, color: str | Tuple[int,int,int,int]=DEFAULT_COLOR):\n        \"\"\"Instantiates a circular object\n\n        Args:\n            name (str): the Virtual Tools name tag\n            space (pm.Space): the pymunk Space the object will be added to\n            position (Tuple[float, float]): the center of the ball\n            radius (float): the radius of the ball in world units\n            density (float, optional): the density of the object. Set to 0 to make the object static. Defaults to DEFAULT_DENSITY.\n            elasticity (float, optional): the elasticity of the object. Defaults to DEFAULT_ELASTICITY.\n            friction (float, optional): the friction of the object. Defaults to DEFAULT_FRICTION.\n            color (str | Tuple[int,int,int,int], optional): either a string or (r,g,b,a) tuple describing the object color. Defaults to DEFAULT_COLOR.\n        \"\"\"       \n        VTObject.__init__(self, name, \"Ball\", space, color, density, friction, elasticity)\n        area = np.pi * radius * radius\n        mass = density * area\n        imom = pm.moment_for_circle(mass, 0, radius)\n        if mass == 0:\n            self._cpShape = pm.Circle(space.static_body, radius, position)\n            self._cpShape.elasticity = elasticity\n            self._cpShape.friction = friction\n            self._cpShape.collision_type = COLTYPE_SOLID\n            self._cpShape.name = name\n            space.add(self._cpShape)\n        else:\n            self._cpBody = pm.Body(mass, imom)\n            self._cpShape = pm.Circle(self._cpBody, radius, (0,0))\n            self._cpShape.elasticity = elasticity\n            self._cpShape.friction = friction\n            self._cpShape.collision_type = COLTYPE_SOLID\n            self._cpShape.name = name\n            self._cpBody.position = position\n            space.add(self._cpBody, self._cpShape)\n\n    def get_radius(self) -&gt; float:\n        return self._cpShape.radius\n\n    def get_area(self) -&gt; float:\n        r = self.get_radius()\n        return np.pi * r * r\n\n    # Overwrites for static circles too\n    def get_pos(self) -&gt; Tuple[float, float]:\n        if self.is_static():\n            return self._cpShape.offset\n        else:\n            return self._cpBody.position\n\n    radius = property(get_radius)\n    area = property(get_area)\n</code></pre>"},{"location":"reference/virtualtools/world/object/#virtualtools.world.object.VTBall.__init__","title":"<code>__init__(name, space, position, radius, density=DEFAULT_DENSITY, elasticity=DEFAULT_ELASTICITY, friction=DEFAULT_FRICTION, color=DEFAULT_COLOR)</code>","text":"<p>Instantiates a circular object</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the Virtual Tools name tag</p> required <code>space</code> <code>Space</code> <p>the pymunk Space the object will be added to</p> required <code>position</code> <code>Tuple[float, float]</code> <p>the center of the ball</p> required <code>radius</code> <code>float</code> <p>the radius of the ball in world units</p> required <code>density</code> <code>float</code> <p>the density of the object. Set to 0 to make the object static. Defaults to DEFAULT_DENSITY.</p> <code>DEFAULT_DENSITY</code> <code>elasticity</code> <code>float</code> <p>the elasticity of the object. Defaults to DEFAULT_ELASTICITY.</p> <code>DEFAULT_ELASTICITY</code> <code>friction</code> <code>float</code> <p>the friction of the object. Defaults to DEFAULT_FRICTION.</p> <code>DEFAULT_FRICTION</code> <code>color</code> <code>str | Tuple[int, int, int, int]</code> <p>either a string or (r,g,b,a) tuple describing the object color. Defaults to DEFAULT_COLOR.</p> <code>DEFAULT_COLOR</code> Source code in <code>virtualtools/world/object.py</code> <pre><code>def __init__(self, name: str, space: pm.Space, position: Tuple[float, float], radius: float,\n             density: float = DEFAULT_DENSITY, elasticity: float=DEFAULT_ELASTICITY,\n             friction: float=DEFAULT_FRICTION, color: str | Tuple[int,int,int,int]=DEFAULT_COLOR):\n    \"\"\"Instantiates a circular object\n\n    Args:\n        name (str): the Virtual Tools name tag\n        space (pm.Space): the pymunk Space the object will be added to\n        position (Tuple[float, float]): the center of the ball\n        radius (float): the radius of the ball in world units\n        density (float, optional): the density of the object. Set to 0 to make the object static. Defaults to DEFAULT_DENSITY.\n        elasticity (float, optional): the elasticity of the object. Defaults to DEFAULT_ELASTICITY.\n        friction (float, optional): the friction of the object. Defaults to DEFAULT_FRICTION.\n        color (str | Tuple[int,int,int,int], optional): either a string or (r,g,b,a) tuple describing the object color. Defaults to DEFAULT_COLOR.\n    \"\"\"       \n    VTObject.__init__(self, name, \"Ball\", space, color, density, friction, elasticity)\n    area = np.pi * radius * radius\n    mass = density * area\n    imom = pm.moment_for_circle(mass, 0, radius)\n    if mass == 0:\n        self._cpShape = pm.Circle(space.static_body, radius, position)\n        self._cpShape.elasticity = elasticity\n        self._cpShape.friction = friction\n        self._cpShape.collision_type = COLTYPE_SOLID\n        self._cpShape.name = name\n        space.add(self._cpShape)\n    else:\n        self._cpBody = pm.Body(mass, imom)\n        self._cpShape = pm.Circle(self._cpBody, radius, (0,0))\n        self._cpShape.elasticity = elasticity\n        self._cpShape.friction = friction\n        self._cpShape.collision_type = COLTYPE_SOLID\n        self._cpShape.name = name\n        self._cpBody.position = position\n        space.add(self._cpBody, self._cpShape)\n</code></pre>"},{"location":"reference/virtualtools/world/object/#virtualtools.world.object.VTPoly","title":"<code>VTPoly</code>","text":"<p>             Bases: <code>VTObject</code></p> Source code in <code>virtualtools/world/object.py</code> <pre><code>class VTPoly(VTObject):\n\n    def __init__(self,name: str, space: pm.Space, vertices: List[Tuple[float,float]],\n                 density: float = DEFAULT_DENSITY, elasticity: float=DEFAULT_ELASTICITY,\n                 friction: float=DEFAULT_FRICTION, color: str | Tuple[int,int,int,int]=DEFAULT_COLOR):\n        \"\"\"Instantiates a convex polygon object\n\n        Args:\n            name (str): the Virtual Tools name tag\n            space (pm.Space): the pymunk Space the object will be added to\n            vertices (List[Tuple[float,float]]): a list of (x,y) vertices making up the polygon\n            density (float, optional): the density of the object. Set to 0 to make the object static. Defaults to DEFAULT_DENSITY.\n            elasticity (float, optional): the elasticity of the object. Defaults to DEFAULT_ELASTICITY.\n            friction (float, optional): the friction of the object. Defaults to DEFAULT_FRICTION.\n            color (str | Tuple[int,int,int,int], optional): either a string or (r,g,b,a) tuple describing the object color. Defaults to DEFAULT_COLOR.\n        \"\"\"        \n        VTObject.__init__(self, name, \"Poly\", space, color, density, friction, elasticity)\n\n        vertices = [[float(vp) for vp in v] for v in vertices]\n        loc = verts_to_vec2d(convex_centroid(vertices))\n        self.area = convex_area(vertices)\n        mass = density * self.area\n\n        if mass == 0:\n            self._cpShape = pm.Poly(space.static_body, vertices)\n            self._cpShape.elasticity = elasticity\n            self._cpShape.friction = friction\n            self._cpShape.collision_type = COLTYPE_SOLID\n            self._cpShape.name = name\n            space.add(self._cpShape)\n        else:\n            vertices = poly_to_vec2d(recenter_polygon(vertices))\n            imom = pm.moment_for_poly(mass, vertices)\n            self._cpBody = pm.Body(mass, imom)\n            self._cpShape = pm.Poly(self._cpBody, vertices)\n            self._cpShape.elasticity = elasticity\n            self._cpShape.friction = friction\n            self._cpShape.collision_type = COLTYPE_SOLID\n            self._cpShape.name = name\n            self._cpBody.position = loc\n            space.add(self._cpBody, self._cpShape)\n\n    def get_vertices(self) -&gt; List[Tuple[float, float]]:\n        \"\"\"Returns the vertices of the polygon\n\n        Returns:\n            List[Tuple[float, float]]: a list of (x,y) vertices\n        \"\"\"        \n        if self.is_static():\n            verts = [np.array(v) for v in self._cpShape.get_vertices()]\n            verts.reverse()\n        else:\n            verts = []\n            pos = self.position\n            rot = self.rotation\n            for v in self._cpShape.get_vertices():\n                vcp = v.rotated(rot) + pos\n                verts = [np.array(vcp)] + verts\n        return verts\n\n    def get_area(self) -&gt; float:\n        \"\"\"Returns the area of the polygon\n\n        Returns:\n            float: the area\n        \"\"\"        \n        return self.area\n\n    # Overwrites for static polygons too\n    def get_pos(self) -&gt; Tuple[float, float]:\n        \"\"\"Gets the centroid of the polygon\n\n        Returns:\n            Tuple[float, float]: the (x,y) centroid as an np.array\n        \"\"\"        \n        if self.is_static():\n            vertices = [[float(vp) for vp in v] for v in self.vertices]\n            return convex_centroid(vertices)\n        else:\n            return np.array(self._cpBody.position)\n\n    \"\"\"Pretty sure this method is inherited so I can ignore...\"\"\"\n    # def distance_from_point(self, point: Tuple[float, float]) -&gt; float:\n    #     d, _ = self._cpShape.point_query(point)\n    #     return d\n\n    vertices = property(get_vertices)\n</code></pre>"},{"location":"reference/virtualtools/world/object/#virtualtools.world.object.VTPoly.__init__","title":"<code>__init__(name, space, vertices, density=DEFAULT_DENSITY, elasticity=DEFAULT_ELASTICITY, friction=DEFAULT_FRICTION, color=DEFAULT_COLOR)</code>","text":"<p>Instantiates a convex polygon object</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the Virtual Tools name tag</p> required <code>space</code> <code>Space</code> <p>the pymunk Space the object will be added to</p> required <code>vertices</code> <code>List[Tuple[float, float]]</code> <p>a list of (x,y) vertices making up the polygon</p> required <code>density</code> <code>float</code> <p>the density of the object. Set to 0 to make the object static. Defaults to DEFAULT_DENSITY.</p> <code>DEFAULT_DENSITY</code> <code>elasticity</code> <code>float</code> <p>the elasticity of the object. Defaults to DEFAULT_ELASTICITY.</p> <code>DEFAULT_ELASTICITY</code> <code>friction</code> <code>float</code> <p>the friction of the object. Defaults to DEFAULT_FRICTION.</p> <code>DEFAULT_FRICTION</code> <code>color</code> <code>str | Tuple[int, int, int, int]</code> <p>either a string or (r,g,b,a) tuple describing the object color. Defaults to DEFAULT_COLOR.</p> <code>DEFAULT_COLOR</code> Source code in <code>virtualtools/world/object.py</code> <pre><code>def __init__(self,name: str, space: pm.Space, vertices: List[Tuple[float,float]],\n             density: float = DEFAULT_DENSITY, elasticity: float=DEFAULT_ELASTICITY,\n             friction: float=DEFAULT_FRICTION, color: str | Tuple[int,int,int,int]=DEFAULT_COLOR):\n    \"\"\"Instantiates a convex polygon object\n\n    Args:\n        name (str): the Virtual Tools name tag\n        space (pm.Space): the pymunk Space the object will be added to\n        vertices (List[Tuple[float,float]]): a list of (x,y) vertices making up the polygon\n        density (float, optional): the density of the object. Set to 0 to make the object static. Defaults to DEFAULT_DENSITY.\n        elasticity (float, optional): the elasticity of the object. Defaults to DEFAULT_ELASTICITY.\n        friction (float, optional): the friction of the object. Defaults to DEFAULT_FRICTION.\n        color (str | Tuple[int,int,int,int], optional): either a string or (r,g,b,a) tuple describing the object color. Defaults to DEFAULT_COLOR.\n    \"\"\"        \n    VTObject.__init__(self, name, \"Poly\", space, color, density, friction, elasticity)\n\n    vertices = [[float(vp) for vp in v] for v in vertices]\n    loc = verts_to_vec2d(convex_centroid(vertices))\n    self.area = convex_area(vertices)\n    mass = density * self.area\n\n    if mass == 0:\n        self._cpShape = pm.Poly(space.static_body, vertices)\n        self._cpShape.elasticity = elasticity\n        self._cpShape.friction = friction\n        self._cpShape.collision_type = COLTYPE_SOLID\n        self._cpShape.name = name\n        space.add(self._cpShape)\n    else:\n        vertices = poly_to_vec2d(recenter_polygon(vertices))\n        imom = pm.moment_for_poly(mass, vertices)\n        self._cpBody = pm.Body(mass, imom)\n        self._cpShape = pm.Poly(self._cpBody, vertices)\n        self._cpShape.elasticity = elasticity\n        self._cpShape.friction = friction\n        self._cpShape.collision_type = COLTYPE_SOLID\n        self._cpShape.name = name\n        self._cpBody.position = loc\n        space.add(self._cpBody, self._cpShape)\n</code></pre>"},{"location":"reference/virtualtools/world/object/#virtualtools.world.object.VTPoly.get_area","title":"<code>get_area()</code>","text":"<p>Returns the area of the polygon</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the area</p> Source code in <code>virtualtools/world/object.py</code> <pre><code>def get_area(self) -&gt; float:\n    \"\"\"Returns the area of the polygon\n\n    Returns:\n        float: the area\n    \"\"\"        \n    return self.area\n</code></pre>"},{"location":"reference/virtualtools/world/object/#virtualtools.world.object.VTPoly.get_pos","title":"<code>get_pos()</code>","text":"<p>Gets the centroid of the polygon</p> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple[float, float]: the (x,y) centroid as an np.array</p> Source code in <code>virtualtools/world/object.py</code> <pre><code>def get_pos(self) -&gt; Tuple[float, float]:\n    \"\"\"Gets the centroid of the polygon\n\n    Returns:\n        Tuple[float, float]: the (x,y) centroid as an np.array\n    \"\"\"        \n    if self.is_static():\n        vertices = [[float(vp) for vp in v] for v in self.vertices]\n        return convex_centroid(vertices)\n    else:\n        return np.array(self._cpBody.position)\n</code></pre>"},{"location":"reference/virtualtools/world/object/#virtualtools.world.object.VTPoly.get_vertices","title":"<code>get_vertices()</code>","text":"<p>Returns the vertices of the polygon</p> <p>Returns:</p> Type Description <code>List[Tuple[float, float]]</code> <p>List[Tuple[float, float]]: a list of (x,y) vertices</p> Source code in <code>virtualtools/world/object.py</code> <pre><code>def get_vertices(self) -&gt; List[Tuple[float, float]]:\n    \"\"\"Returns the vertices of the polygon\n\n    Returns:\n        List[Tuple[float, float]]: a list of (x,y) vertices\n    \"\"\"        \n    if self.is_static():\n        verts = [np.array(v) for v in self._cpShape.get_vertices()]\n        verts.reverse()\n    else:\n        verts = []\n        pos = self.position\n        rot = self.rotation\n        for v in self._cpShape.get_vertices():\n            vcp = v.rotated(rot) + pos\n            verts = [np.array(vcp)] + verts\n    return verts\n</code></pre>"},{"location":"reference/virtualtools/world/world/","title":"world","text":""},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld","title":"<code>VTWorld</code>","text":"<p>             Bases: <code>object</code></p> Source code in <code>virtualtools/world/world.py</code> <pre><code>class VTWorld(object):\n\n    def __init__(self,\n                 dimensions: Tuple[float, float],\n                 gravity: float,\n                 closed_ends: Annotated[Tuple[bool], 4] = [True,True,True,True],\n                 basic_timestep: float = 0.01,\n                 def_density: float = DEFAULT_DENSITY,\n                 def_elasticity: float = DEFAULT_ELASTICITY,\n                 def_friction: float = DEFAULT_FRICTION,\n                 bk_col: Annotated[Tuple[int], 3] = (255,255,255),\n                 def_col: Annotated[Tuple[int], 3] = (0,0,0)):\n        \"\"\"Instantiates a virtual tools world\n\n        Args:\n            dimensions (Tuple[float, float]): the (x,y) limits of the world\n            gravity (float): the strength of gravity pointing down in units/s^2\n            closed_ends (Annotated[Tuple[bool], 4], optional): a set of flags to say whether a [left, bottom, right, top] wall should be added around the world. Defaults to [True,True,True,True].\n            basic_timestep (float, optional): the amount of time to step forward when calculatign physics. Smaller values will slow down the simulation but be more precise. Larger values might cause \"tunneling\" or other physics instabilities. Defaults to 0.01.\n            def_density (float, optional): the default density of all objects in the world, unless otherwise specified. Defaults to 1.\n            def_elasticity (float, optional): the default elasticity of all objects in the world, unless otherwise specified. Defaults to 0.5.\n            def_friction (float, optional): _description_. the default friction of all objects in the world, unless otherwise specified. Defaults to 0.5.\n            bk_col (Annotated[Tuple[int], 3], optional): the RGB value of the background of the tools world. Defaults to white (255,255,255).\n            def_col (Annotated[Tuple[int], 3], optional): the default RGB color of objects added to the world. Not guaranteed to catch. Defaults to black (0,0,0).\n        \"\"\"        \n\n        self.def_density = def_density\n        self.def_elasticity = def_elasticity\n        self.def_friction = def_friction\n        self.bk_col = bk_col\n        self.def_col = def_col\n\n        self.dims = dimensions\n        self.bts = basic_timestep\n        self.time = 0\n        self.has_place_collision = False\n\n        self._cpSpace = pm.Space()\n        self._cpSpace.gravity = (0, -gravity)\n        self._cpSpace.sleep_time_threshold = 5.\n\n        self.objects = dict()\n        self.blockers = dict()\n        self.constraints = dict() # Not implemented yet\n\n        self.goal_cond = None\n        self.win_callback = None\n        self._collision_events = []\n        self._ssBegin = _empty_collision_handler\n        self._ssPre = _empty_collision_handler\n        self._ssPost = _empty_collision_handler\n        self._ssEnd = _empty_collision_handler\n        self._sgBegin = _empty_collision_handler\n        self._sgEnd = _empty_collision_handler\n\n        def do_solid_solid_begin(arb, space, data):\n            return self._solid_solid_begin(arb, space, data)\n        def do_solid_solid_pre(arb, space, data):\n            return self._solid_solid_pre(arb, space, data)\n        def do_solid_solid_post(arb, space, data):\n            return self._solid_solid_post(arb, space, data)\n        def do_solid_solid_end(arb, space, data):\n            return self._solid_solid_end(arb, space, data)\n        def do_solid_goal_begin(arb, space, data):\n            return self._solid_goal_begin(arb, space, data)\n        def do_solid_goal_end(arb, space, data):\n            return self._solid_goal_end(arb, space, data)\n\n        ssch = self._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SOLID)\n        ssch.begin = do_solid_solid_begin\n        ssch.pre_solve = do_solid_solid_pre\n        ssch.post_solve = do_solid_solid_post\n        ssch.separate = do_solid_solid_end\n\n        psch = self._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SOLID)\n        psch.begin = do_solid_solid_begin\n        psch.pre_solve = do_solid_solid_pre\n        psch.post_solve = do_solid_solid_post\n        psch.separate = do_solid_solid_end\n\n        ssench = self._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SENSOR)\n        ssench.begin = do_solid_goal_begin\n        ssench.separate = do_solid_goal_end\n\n        psench = self._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SENSOR)\n        psench.begin = do_solid_goal_begin\n        psench.separate = do_solid_goal_end\n\n        if closed_ends[0]:\n            self.add_box(\"_LeftWall\",[-1,-1,1,self.dims[1]+1], self.def_col, 0)\n        if closed_ends[1]:\n            self.add_box(\"_BottomWall\", [-1,-1,self.dims[0]+1, 1], self.def_col, 0);\n        if closed_ends[2]:\n            self.add_box(\"_RightWall\", [self.dims[0] - 1, -1, self.dims[0] + 1, self.dims[1] + 1], self.def_col, 0);\n        if closed_ends[3]:\n            self.add_box(\"_TopWall\", [-1, self.dims[1] - 1, self.dims[0] + 1, self.dims[1] + 1], self.def_col, 0);\n\n    def step(self, t: float):\n        \"\"\"Steps the world forward by t seconds. Not that this will not affect the precision of physics simulation; that is done via the `basic_timestep` value upon initialization\n\n        Args:\n            t (float): the amount of time (in seconds) to step forward\n        \"\"\"        \n        nsteps = int(np.floor(t / self.bts))\n        remtime = self.bts % t\n        self.time += t\n        for i in range(nsteps):\n            self._cpSpace.step(self.bts)\n            if self.check_end() and self.win_callback is not None:\n                self.win_callback()\n        if remtime / self.bts &gt; .01:\n            self._cpSpace.step(remtime)\n        if self.check_end() and self.win_callback is not None:\n            self.win_callback()\n\n    def _invert(self, pt):\n        return (pt[0], self.dims[1] - pt[1])\n\n    def _yinvert(self, y):\n        return self.dims[1] - y\n\n    def check_end(self) -&gt; bool:\n        \"\"\"Returns whether the victory condition of the world has been cleared\n\n        Returns:\n            bool: true if victory is achieved; false if not (or if no condition exists)\n        \"\"\"        \n        if self.goal_cond is None:\n            return False\n        return self.goal_cond.is_won()\n\n    def get_object(self, name: str) -&gt; VTObject:\n        \"\"\"Returns an object that exists in the world\n\n        Args:\n            name (str): the Virtual Tools name flag of the object\n\n        Returns:\n            VTObject: the object within the world\n\n        Raises:\n            AssertionError: if the object doesn't exist\n        \"\"\"        \n        assert name in self.objects.keys(), \"No object by that name: \" + name\n        return self.objects[name]\n\n    def get_gravity(self) -&gt; float:\n        \"\"\"Returns the gravity in units/s^2 downwards\n\n        Returns:\n            float: gravity\n        \"\"\"        \n        return -self._cpSpace.gravity.y\n\n    def set_gravity(self, val: float):\n        \"\"\"Sets the gravity in units/s^2 downwards. Negative values make things fall \"up\"\n\n        Args:\n            val (float): gravity\n        \"\"\"        \n        self._cpSpace.gravity = (0, -val)\n\n    ########################################\n    # Adding things to the world\n    ########################################\n    def add_poly(self,\n                 name, vertices, color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        this_obj = VTPoly(name, self._cpSpace, vertices, density, elasticity, friction, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_box(self, name, bounds, color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        assert len(bounds) == 4, \"Need four numbers for bounds [l,b,r,t]\"\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        l = bounds[0]\n        b = bounds[1]\n        r = bounds[2]\n        t = bounds[3]\n        vertices = [(l,b), (l,t), (r,t), (r,b)]\n\n        this_obj = VTPoly(name, self._cpSpace, vertices, density, elasticity, friction, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_ball(self, name, position, radius, color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        this_obj = VTBall(name, self._cpSpace, position, radius, density, elasticity, friction, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_segment(self, name, p1, p2, width, color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        this_obj = VTSeg(name, self._cpSpace, p1, p2, width, density, elasticity, friction, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_container(self, name, ptlist, width, inner_color, outer_color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        this_obj = VTContainer(name, self._cpSpace, ptlist, width, density, elasticity, friction, inner_color, outer_color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_compound(self, name, polys, color, density = None, elasticity = None, friction = None):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        if density is None:\n            density = self.def_density\n        if elasticity is None:\n            elasticity = self.def_elasticity\n        if friction is None:\n            friction = self.def_friction\n\n        this_obj = VTCompound(name, self._cpSpace, polys, density, elasticity, friction, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_poly_goal(self, name, vertices, color):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        this_obj = VTGoal(name, self._cpSpace, vertices, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_box_goal(self, name, bounds, color):\n        assert name not in self.objects.keys(), \"Name already taken: \" + name\n        assert len(bounds) == 4, \"Need four numbers for bounds [l,b,r,t]\"\n        l = bounds[0]\n        b = bounds[1]\n        r = bounds[2]\n        t = bounds[3]\n        vertices = [(l, b), (l, t), (r, t), (r, b)]\n        this_obj = VTGoal(name, self._cpSpace, vertices, color)\n        self.objects[name] = this_obj\n        return this_obj\n\n    def add_placed_poly(self, name, vertices, color, density = None, elasticity = None, friction = None):\n        this_obj = self.add_poly(name, vertices, color, density, elasticity, friction)\n        this_obj._cpShape.collision_type = COLTYPE_PLACED\n        return this_obj\n\n    def add_placed_compound(self, name, polys, color, density = None, elasticity = None, friction = None):\n        this_obj = self.add_compound(name, polys, color, density, elasticity, friction)\n        for cpsh in this_obj._cpShapes:\n            cpsh.collision_type = COLTYPE_PLACED\n        return this_obj\n\n    def add_placed_circle(self, name, position, radius, color, density=None, elasticity=None, friction=None):\n        this_obj = self.add_ball(name, position, radius, color, density, elasticity, friction)\n        this_obj._cpShape.collision_type = COLTYPE_PLACED\n        return this_obj\n\n    def add_block(self, name, bounds, color):\n        assert name not in self.blockers.keys(), \"Name already taken: \" + name\n        assert len(bounds) == 4, \"Need four numbers for bounds [l,b,r,t]\"\n        l = bounds[0]\n        b = bounds[1]\n        r = bounds[2]\n        t = bounds[3]\n        vertices = [(l, b), (l, t), (r, t), (r, b)]\n        this_obj = VTBlocker(name, self._cpSpace, vertices, color)\n        self.blockers[name] = this_obj\n        return this_obj\n\n    def add_poly_block(self, name, vertices, color):\n        assert name not in self.blockers.keys(), \"Name already taken: \" + name\n        this_obj = VTBlocker(name, self._cpSpace, vertices, color)\n        self.blockers[name] = this_obj\n        return this_obj\n\n    ########################################\n    # Callbacks\n    ########################################\n    def get_solid_collision_pre(self) -&gt; Callable:\n        return self._ssPre\n\n    def set_solid_collision_pre(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._ssPre = fnc\n\n    def get_solid_collision_post(self) -&gt; Callable:\n        return self._ssPost\n\n    def set_solid_collision_post(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._ssPost = fnc\n\n    def get_solid_collision_begin(self) -&gt; Callable:\n        return self._ssBegin\n\n    def set_solid_collision_begin(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._ssBegin = fnc\n\n    def get_solid_collision_end(self) -&gt; Callable:\n        return self._ssEnd\n\n    def set_solid_collision_end(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._ssEnd = fnc\n\n    def get_goal_collision_begin(self) -&gt; Callable:\n        return self._sgBegin\n\n    def set_goal_collision_begin(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._sgBegin = fnc\n\n    def get_goal_collision_end(self) -&gt; Callable:\n        return self._sgEnd\n\n    def set_goal_collision_end(self, fnc: Callable = _empty_object_handler):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self._sgEnd = fnc\n\n    def _solid_solid_pre(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        self._ssPre(o1,o2)\n        return True\n\n    def _solid_solid_post(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        self._ssPost(o1, o2)\n        return True\n\n    def _solid_solid_begin(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        # Add any non-static/static collisions to the events\n        if not (o1.is_static() and o2.is_static()):\n            collision_info = pull_collision_information(arb)\n            self._collision_events.append([onms[0],onms[1], \"begin\",self.time, collision_info])\n        self._ssBegin(o1, o2)\n        return True\n\n    def _solid_solid_end(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        # Add any non-static/static collisions to the events\n        if not (o1.is_static() and o2.is_static()):\n            collision_info = pull_collision_information(arb)\n            self._collision_events.append([onms[0], onms[1], \"end\", self.time, collision_info])\n        self._ssEnd(o1, o2)\n        return True\n\n    def _solid_goal_begin(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        self._sgBegin(o1, o2)\n        return True\n\n    def _solid_goal_end(self, arb, space, data):\n        onms = resolve_arbiter(arb)\n        o1 = self.get_object(onms[0])\n        o2 = self.get_object(onms[1])\n        self._sgEnd(o1, o2)\n        return True\n\n    ########################################\n    # Victory conditions\n    ########################################\n    def _get_callback_on_win(self):\n        return self.win_callback\n\n    def _set_callback_on_win(self, fnc):\n        assert callable(fnc), \"Must pass legal function to callback setter\"\n        self.win_callback = fnc\n\n    def attach_any_in_goal(self, goalname: str, duration: float, exclusions: List[str] = []):\n        \"\"\"Sets a victory condition in which any object can make it into the goal area (except those specified in exclusions)\n\n        Args:\n            goalname (str): the Virtual Tools name of the goal object\n            duration (float): the amount of time (in seconds) an object must remain in the goal\n            exclusions (List[str], optional): a list of Virtual Tools names of objects that will *not* trigger victory. Defaults to [].\n        \"\"\"        \n        self.goal_cond = VTCond_AnyInGoal(goalname, duration, self, exclusions)\n        self.goal_cond.attach_hooks()\n\n    def attach_specific_in_goal(self, goalname: str, objname: str, duration: float):\n        \"\"\"Sets a victory condition in which a specific object must make it into a specific goal area\n\n        Args:\n            goalname (str): the Virtual Tools name of the goal object\n            objname (str): the Virtual Tools name of the target object to go into the goal\n            duration (float): the amount of time (in seconds) an object must remain in the goal\n        \"\"\"        \n        self.goal_cond = VTCond_SpecificInGoal(goalname, objname, duration, self)\n        self.goal_cond.attach_hooks()\n\n    def attach_many_in_goal(self, goalname: str, objlist: List[str], duration: float):\n        \"\"\"Sets a victory condition in which any of a set of objects must make it into a specific goal area\n\n        Args:\n            goalname (str): the Virtual Tools name of the goal object\n            objlist (List[str]): a list of Virtual Tools names of objects to go into the goal\n            duration (float): the amount of time (in seconds) an object must remain in the goal\n        \"\"\"        \n        self.goal_cond = VTCond_ManyInGoal(goalname, objlist, duration, self)\n        self.goal_cond.attach_hooks()\n\n    def attach_any_touch(self, objname: str, duration: float):\n        \"\"\"Sets a victory condition in which any dynamic object must touch a specific object\n\n        Args:\n            objname (str): the Virtual Tools name of the target object to be touched\n            duration (float): the amount of time (in seconds) the objects must remain in contact\n        \"\"\"        \n        self.goal_cond = VTCond_AnyTouch(objname, duration, self)\n        self.goal_cond.attach_hooks()\n\n    def attach_specific_touch(self, obj1: str, obj2: str, duration: float):\n        \"\"\"Sets a victory condition in which two objects must come into contact\n\n        Args:\n            obj1 (str): the Virtual Tools name of one of the target objects\n            obj2 (str): the Virtual Tools name of the other target object\n            duration (float): the amount of time (in seconds) the objects must remain in contact\n        \"\"\"        \n        self.goal_cond = VTCond_SpecificTouch(obj1, obj2, duration, self)\n        self.goal_cond.attach_hooks()\n\n    def check_finishers(self) -&gt; bool:\n        \"\"\"Makes sure there is a way to exit the world -- a victory condition and a win_callback that happens afterwards\n\n        Returns:\n            bool: true if goal_cond and win_callback exist, false otherwise\n        \"\"\"        \n        return self.goal_cond is not None and self.win_callback is not None\n\n    ########################################\n    # Checking collisions\n    ########################################\n\n    def reset_collisions(self):\n        \"\"\"Clears out the collision events list\n        \"\"\"        \n        self._collision_events = []\n\n    def _get_collision_events(self):\n        return self._collision_events\n\n    ########################################\n    # Misc\n    ########################################\n    def check_collision(self, pos: Tuple[float, float], verts: List[Tuple[float, float]]) -&gt; bool:\n        \"\"\"Checks whether placing a convex polygon in the world would cause a collision\n\n        Args:\n            pos (Tuple[float, float]): the position of the hypothetical polygon (where all vertices are calculated wrt)\n            verts (List[Tuple[float, float]]): a list of (x,y) vertices of the convex polygon, relative to the position\n\n        Returns:\n            bool: true if there would be a collision, false if not\n        \"\"\"        \n        nvert = [(v[0]+pos[0], v[1]+pos[1]) for v in verts]\n        tmpBody = pm.Body(1,1)\n        placeShape = pm.Poly(tmpBody, nvert)\n        placeShape.collision_type = COLTYPE_CHECKER\n        placeShape.sensor = True\n        self._cpSpace.step(.000001)\n\n        self.has_place_collision = False\n        squery = self._cpSpace.shape_query(placeShape)\n        \"\"\" Code doesn't account for blockers (sensors)\n        # Update 12/12/23: I don't see why this wouldn't but if you're getting incorrect output, check the blockers!\n        if len(squery) == 0:\n            return False\n        else:\n            for sq in squery:\n                for p in sq.contact_point_set.points:\n                    if p.distance &gt; 0:\n                        return True\n            return False\n        \"\"\"\n        return len(squery) &gt; 0\n\n    def check_circle_collision(self, pos: Tuple[float, float], rad: float) -&gt; bool:\n        \"\"\"Checks if there would be a colision with an object if a circular object were placed in the world\n\n        Args:\n            pos (Tuple[float, float]): the center of the hypothetical circular object\n            rad (float): the radius of the hypothetical circular object\n\n        Returns:\n            bool: true if there would be a colision, false if not\n        \"\"\"        \n        tmpBody = pm.Body(1,1)\n        placeShape = pm.Circle(tmpBody, rad, pos)\n        placeShape.collision_type = COLTYPE_CHECKER\n        placeShape.sensor = True\n        self._cpSpace.step(.000001)\n\n        self.has_place_collision = False\n        squery = self._cpSpace.shape_query(placeShape)\n        return len(squery) &gt; 0\n\n    def kick(self, objectname: str, impulse: Tuple[float, float], position: Tuple[float, float]):\n        \"\"\"Applies an impulse to an object at a particular point\n\n        Args:\n            objectname (str): the Virtual Tools name of the object in this world\n            impulse (Tuple[float, float]): the impulse (momentum) vector\n            position (Tuple[float, float]): the point to apply the impulse to in world coordinates. Note: this must be inside the object!\n        \"\"\"        \n        o = self.get_object(objectname)\n        o.kick(impulse, position)\n\n    def distance_to_goal(self, point: Tuple[float, float]) -&gt; float:\n        \"\"\"Returns the distance between the nearest object achieving victory and the goal area / other object\n\n        WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!\n\n        Args:\n            point (Tuple[float, float]): _description_\n\n        Returns:\n            float: _description_\n\n        Raises:\n            AssertionError: if no goal condition is specified\n        \"\"\"        \n        assert self.goal_cond, \"Goal condition must be specified to get distance\"\n        warnings.warn(\"This function is old and looks wrong - be careful using it\")\n        # Special case... requires getting two distances\n        if type(self.goal_cond) == VTCond_SpecificTouch:\n            o1 = self.get_object(self.goal_cond.o1)\n            o2 = self.get_object(self.goal_cond.o2)\n            #in this case, we actually want the distance between these two objects...\n            return np.abs(o1.distance_from_point([0,0]) - o2.distance_from_point([0,0])) #distance between these two objects is thing that matters\n        else:\n            gobj = self.get_object(self.goal_cond.goal)\n            return max(gobj.distance_from_point(point), 0)\n\n    def distance_to_goal_container(self, point: Tuple[float, float]):\n        \"\"\"Returns the distance between the nearest object achieving victory and the goal area / other object; specifies that for container objects, you want the distance to the top of the container\n\n        WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!\n\n\n        Args:\n            point (Tuple[float, float]): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        assert self.goal_cond, \"Goal condition must be specified to get distance\"\n        warnings.warn(\"This function is old and looks wrong - be careful using it\")\n        try:\n            # Special case... requires getting two distances\n            if type(self.goal_cond) == VTCond_SpecificTouch:\n                o1 = self.get_object(self.goal_cond.o1)\n                o2 = self.get_object(self.goal_cond.o2)\n                #in this case, we actually want the distance between these two objects...\n                return np.abs(o1.distance_from_point([0,0]) - o2.distance_from_point([0,0])) #distance between these two objects is thing that matters\n            else:\n                gobj = self.get_object(self.goal_cond.goal)\n                if gobj.type != 'Container':\n                    return gobj.distance_from_point(point)\n                else:\n                    if self.distance_to_goal(point) == 0:\n                        return 0\n                    else:\n                        return distance_to_object(gobj, point)\n        except:\n            pdb.set_trace()\n\n    def get_dynamic_objects(self) -&gt; List[VTObject]:\n        \"\"\"Returns a list of all dynamic (not static) objects in the world\n\n        Returns:\n            List[VTObject]: a List of all of the dynamics VTObjects\n        \"\"\"        \n        return [self.objects[i] for i in self.objects.keys() if not self.objects[i].is_static()]\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"Outputs a JSON-serializable Dict describing the world\n\n        Raises:\n            Exception: if invalid object or goal types exist in the world. In theory this should never happen\n\n        Returns:\n            Dict: a JSON-serializable Dict\n        \"\"\"        \n        wdict = dict()\n        wdict['dims'] = tuple(self.dims)\n        wdict['bts'] = self.bts\n        wdict['gravity'] = self.gravity\n        wdict['defaults'] = dict(density=self.def_density, friction=self.def_friction,\n                                 elasticity=self.def_elasticity, color=self.def_col, bk_color=self.bk_col)\n\n        wdict['objects'] = dict()\n        for nm, o in self.objects.items():\n            attrs = dict(type=o.type, color=list(o.color), density=o.density,\n                         friction=o.friction, elasticity=o.elasticity)\n            if o.type == 'Poly':\n                attrs['vertices'] = _listify(o.vertices)\n            elif o.type == 'Ball':\n                attrs['position'] = list(o.position)\n                attrs['radius'] = o.radius\n            elif o.type == 'Segment':\n                attrs['p1'], attrs['p2'] = _listify(o.points)\n                attrs['width'] = o.r * 2\n            elif o.type == 'Container':\n                attrs['points'] = _listify(o.vertices)\n                attrs['width'] = o.r * 2\n                attrs['innerColor'] = o.inner_color\n                attrs['outerColor'] = o.outer_color\n            elif o.type == 'Goal':\n                attrs['vertices'] = _listify(o.vertices)\n            elif o.type == 'Compound':\n                attrs['polys'] = _listify(o.polys)\n            else:\n                raise Exception('Invalid object type provided')\n            wdict['objects'][nm] = attrs\n\n        wdict['blocks'] = dict()\n        for nm, b in self.blockers.items():\n            attrs = {'color': list(b.color), 'vertices': _listify(b.vertices)}\n            wdict['blocks'][nm] = attrs\n\n        wdict['constraints'] = dict()\n\n        if self.goal_cond is None:\n            wdict['gcond'] = None\n        else:\n            gc = self.goal_cond\n            if gc.type == 'AnyInGoal':\n                wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': '-',\n                                  'exclusions': gc.excl, 'duration': gc.dur}\n            elif gc.type == 'SpecificInGoal':\n                wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': gc.obj, 'duration': gc.dur}\n            elif gc.type == 'ManyInGoal':\n                wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'objlist': gc.objlist, 'duration': gc.dur}\n            elif gc.type == \"AnyTouch\":\n                wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': '-', 'duration': gc.dur}\n            elif gc.type == 'SpecificTouch':\n                wdict['gcond'] = {'type': gc.type, 'goal': gc.o1, 'obj': gc.o2, 'duration': gc.dur}\n            else:\n                raise Exception('Invalid goal condition type provided')\n\n        return wdict\n\n    def copy(self):\n        return load_vt_from_dict(self.to_dict())\n\n    ########################################\n    # Properties\n    ########################################\n    gravity = property(get_gravity, set_gravity)\n    solid_collision_pre = property(get_solid_collision_pre,\n                                    set_solid_collision_pre)\n    solid_collision_post = property(get_solid_collision_post,\n                                     set_solid_collision_post)\n    solid_collision_begin = property(get_solid_collision_begin,\n                                    set_solid_collision_begin)\n    solid_collision_end = property(get_solid_collision_end,\n                                  set_solid_collision_end)\n    goal_collision_begin = property(get_goal_collision_begin,\n                                   set_goal_collision_begin)\n    goal_collision_end = property(get_goal_collision_end,\n                                 set_goal_collision_end)\n    callback_on_win = property(_get_callback_on_win, _set_callback_on_win)\n    collision_events = property(_get_collision_events)\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.__init__","title":"<code>__init__(dimensions, gravity, closed_ends=[True, True, True, True], basic_timestep=0.01, def_density=DEFAULT_DENSITY, def_elasticity=DEFAULT_ELASTICITY, def_friction=DEFAULT_FRICTION, bk_col=(255, 255, 255), def_col=(0, 0, 0))</code>","text":"<p>Instantiates a virtual tools world</p> <p>Parameters:</p> Name Type Description Default <code>dimensions</code> <code>Tuple[float, float]</code> <p>the (x,y) limits of the world</p> required <code>gravity</code> <code>float</code> <p>the strength of gravity pointing down in units/s^2</p> required <code>closed_ends</code> <code>Annotated[Tuple[bool], 4]</code> <p>a set of flags to say whether a [left, bottom, right, top] wall should be added around the world. Defaults to [True,True,True,True].</p> <code>[True, True, True, True]</code> <code>basic_timestep</code> <code>float</code> <p>the amount of time to step forward when calculatign physics. Smaller values will slow down the simulation but be more precise. Larger values might cause \"tunneling\" or other physics instabilities. Defaults to 0.01.</p> <code>0.01</code> <code>def_density</code> <code>float</code> <p>the default density of all objects in the world, unless otherwise specified. Defaults to 1.</p> <code>DEFAULT_DENSITY</code> <code>def_elasticity</code> <code>float</code> <p>the default elasticity of all objects in the world, unless otherwise specified. Defaults to 0.5.</p> <code>DEFAULT_ELASTICITY</code> <code>def_friction</code> <code>float</code> <p>description. the default friction of all objects in the world, unless otherwise specified. Defaults to 0.5.</p> <code>DEFAULT_FRICTION</code> <code>bk_col</code> <code>Annotated[Tuple[int], 3]</code> <p>the RGB value of the background of the tools world. Defaults to white (255,255,255).</p> <code>(255, 255, 255)</code> <code>def_col</code> <code>Annotated[Tuple[int], 3]</code> <p>the default RGB color of objects added to the world. Not guaranteed to catch. Defaults to black (0,0,0).</p> <code>(0, 0, 0)</code> Source code in <code>virtualtools/world/world.py</code> <pre><code>def __init__(self,\n             dimensions: Tuple[float, float],\n             gravity: float,\n             closed_ends: Annotated[Tuple[bool], 4] = [True,True,True,True],\n             basic_timestep: float = 0.01,\n             def_density: float = DEFAULT_DENSITY,\n             def_elasticity: float = DEFAULT_ELASTICITY,\n             def_friction: float = DEFAULT_FRICTION,\n             bk_col: Annotated[Tuple[int], 3] = (255,255,255),\n             def_col: Annotated[Tuple[int], 3] = (0,0,0)):\n    \"\"\"Instantiates a virtual tools world\n\n    Args:\n        dimensions (Tuple[float, float]): the (x,y) limits of the world\n        gravity (float): the strength of gravity pointing down in units/s^2\n        closed_ends (Annotated[Tuple[bool], 4], optional): a set of flags to say whether a [left, bottom, right, top] wall should be added around the world. Defaults to [True,True,True,True].\n        basic_timestep (float, optional): the amount of time to step forward when calculatign physics. Smaller values will slow down the simulation but be more precise. Larger values might cause \"tunneling\" or other physics instabilities. Defaults to 0.01.\n        def_density (float, optional): the default density of all objects in the world, unless otherwise specified. Defaults to 1.\n        def_elasticity (float, optional): the default elasticity of all objects in the world, unless otherwise specified. Defaults to 0.5.\n        def_friction (float, optional): _description_. the default friction of all objects in the world, unless otherwise specified. Defaults to 0.5.\n        bk_col (Annotated[Tuple[int], 3], optional): the RGB value of the background of the tools world. Defaults to white (255,255,255).\n        def_col (Annotated[Tuple[int], 3], optional): the default RGB color of objects added to the world. Not guaranteed to catch. Defaults to black (0,0,0).\n    \"\"\"        \n\n    self.def_density = def_density\n    self.def_elasticity = def_elasticity\n    self.def_friction = def_friction\n    self.bk_col = bk_col\n    self.def_col = def_col\n\n    self.dims = dimensions\n    self.bts = basic_timestep\n    self.time = 0\n    self.has_place_collision = False\n\n    self._cpSpace = pm.Space()\n    self._cpSpace.gravity = (0, -gravity)\n    self._cpSpace.sleep_time_threshold = 5.\n\n    self.objects = dict()\n    self.blockers = dict()\n    self.constraints = dict() # Not implemented yet\n\n    self.goal_cond = None\n    self.win_callback = None\n    self._collision_events = []\n    self._ssBegin = _empty_collision_handler\n    self._ssPre = _empty_collision_handler\n    self._ssPost = _empty_collision_handler\n    self._ssEnd = _empty_collision_handler\n    self._sgBegin = _empty_collision_handler\n    self._sgEnd = _empty_collision_handler\n\n    def do_solid_solid_begin(arb, space, data):\n        return self._solid_solid_begin(arb, space, data)\n    def do_solid_solid_pre(arb, space, data):\n        return self._solid_solid_pre(arb, space, data)\n    def do_solid_solid_post(arb, space, data):\n        return self._solid_solid_post(arb, space, data)\n    def do_solid_solid_end(arb, space, data):\n        return self._solid_solid_end(arb, space, data)\n    def do_solid_goal_begin(arb, space, data):\n        return self._solid_goal_begin(arb, space, data)\n    def do_solid_goal_end(arb, space, data):\n        return self._solid_goal_end(arb, space, data)\n\n    ssch = self._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SOLID)\n    ssch.begin = do_solid_solid_begin\n    ssch.pre_solve = do_solid_solid_pre\n    ssch.post_solve = do_solid_solid_post\n    ssch.separate = do_solid_solid_end\n\n    psch = self._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SOLID)\n    psch.begin = do_solid_solid_begin\n    psch.pre_solve = do_solid_solid_pre\n    psch.post_solve = do_solid_solid_post\n    psch.separate = do_solid_solid_end\n\n    ssench = self._cpSpace.add_collision_handler(COLTYPE_SOLID, COLTYPE_SENSOR)\n    ssench.begin = do_solid_goal_begin\n    ssench.separate = do_solid_goal_end\n\n    psench = self._cpSpace.add_collision_handler(COLTYPE_PLACED, COLTYPE_SENSOR)\n    psench.begin = do_solid_goal_begin\n    psench.separate = do_solid_goal_end\n\n    if closed_ends[0]:\n        self.add_box(\"_LeftWall\",[-1,-1,1,self.dims[1]+1], self.def_col, 0)\n    if closed_ends[1]:\n        self.add_box(\"_BottomWall\", [-1,-1,self.dims[0]+1, 1], self.def_col, 0);\n    if closed_ends[2]:\n        self.add_box(\"_RightWall\", [self.dims[0] - 1, -1, self.dims[0] + 1, self.dims[1] + 1], self.def_col, 0);\n    if closed_ends[3]:\n        self.add_box(\"_TopWall\", [-1, self.dims[1] - 1, self.dims[0] + 1, self.dims[1] + 1], self.def_col, 0);\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.attach_any_in_goal","title":"<code>attach_any_in_goal(goalname, duration, exclusions=[])</code>","text":"<p>Sets a victory condition in which any object can make it into the goal area (except those specified in exclusions)</p> <p>Parameters:</p> Name Type Description Default <code>goalname</code> <code>str</code> <p>the Virtual Tools name of the goal object</p> required <code>duration</code> <code>float</code> <p>the amount of time (in seconds) an object must remain in the goal</p> required <code>exclusions</code> <code>List[str]</code> <p>a list of Virtual Tools names of objects that will not trigger victory. Defaults to [].</p> <code>[]</code> Source code in <code>virtualtools/world/world.py</code> <pre><code>def attach_any_in_goal(self, goalname: str, duration: float, exclusions: List[str] = []):\n    \"\"\"Sets a victory condition in which any object can make it into the goal area (except those specified in exclusions)\n\n    Args:\n        goalname (str): the Virtual Tools name of the goal object\n        duration (float): the amount of time (in seconds) an object must remain in the goal\n        exclusions (List[str], optional): a list of Virtual Tools names of objects that will *not* trigger victory. Defaults to [].\n    \"\"\"        \n    self.goal_cond = VTCond_AnyInGoal(goalname, duration, self, exclusions)\n    self.goal_cond.attach_hooks()\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.attach_any_touch","title":"<code>attach_any_touch(objname, duration)</code>","text":"<p>Sets a victory condition in which any dynamic object must touch a specific object</p> <p>Parameters:</p> Name Type Description Default <code>objname</code> <code>str</code> <p>the Virtual Tools name of the target object to be touched</p> required <code>duration</code> <code>float</code> <p>the amount of time (in seconds) the objects must remain in contact</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def attach_any_touch(self, objname: str, duration: float):\n    \"\"\"Sets a victory condition in which any dynamic object must touch a specific object\n\n    Args:\n        objname (str): the Virtual Tools name of the target object to be touched\n        duration (float): the amount of time (in seconds) the objects must remain in contact\n    \"\"\"        \n    self.goal_cond = VTCond_AnyTouch(objname, duration, self)\n    self.goal_cond.attach_hooks()\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.attach_many_in_goal","title":"<code>attach_many_in_goal(goalname, objlist, duration)</code>","text":"<p>Sets a victory condition in which any of a set of objects must make it into a specific goal area</p> <p>Parameters:</p> Name Type Description Default <code>goalname</code> <code>str</code> <p>the Virtual Tools name of the goal object</p> required <code>objlist</code> <code>List[str]</code> <p>a list of Virtual Tools names of objects to go into the goal</p> required <code>duration</code> <code>float</code> <p>the amount of time (in seconds) an object must remain in the goal</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def attach_many_in_goal(self, goalname: str, objlist: List[str], duration: float):\n    \"\"\"Sets a victory condition in which any of a set of objects must make it into a specific goal area\n\n    Args:\n        goalname (str): the Virtual Tools name of the goal object\n        objlist (List[str]): a list of Virtual Tools names of objects to go into the goal\n        duration (float): the amount of time (in seconds) an object must remain in the goal\n    \"\"\"        \n    self.goal_cond = VTCond_ManyInGoal(goalname, objlist, duration, self)\n    self.goal_cond.attach_hooks()\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.attach_specific_in_goal","title":"<code>attach_specific_in_goal(goalname, objname, duration)</code>","text":"<p>Sets a victory condition in which a specific object must make it into a specific goal area</p> <p>Parameters:</p> Name Type Description Default <code>goalname</code> <code>str</code> <p>the Virtual Tools name of the goal object</p> required <code>objname</code> <code>str</code> <p>the Virtual Tools name of the target object to go into the goal</p> required <code>duration</code> <code>float</code> <p>the amount of time (in seconds) an object must remain in the goal</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def attach_specific_in_goal(self, goalname: str, objname: str, duration: float):\n    \"\"\"Sets a victory condition in which a specific object must make it into a specific goal area\n\n    Args:\n        goalname (str): the Virtual Tools name of the goal object\n        objname (str): the Virtual Tools name of the target object to go into the goal\n        duration (float): the amount of time (in seconds) an object must remain in the goal\n    \"\"\"        \n    self.goal_cond = VTCond_SpecificInGoal(goalname, objname, duration, self)\n    self.goal_cond.attach_hooks()\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.attach_specific_touch","title":"<code>attach_specific_touch(obj1, obj2, duration)</code>","text":"<p>Sets a victory condition in which two objects must come into contact</p> <p>Parameters:</p> Name Type Description Default <code>obj1</code> <code>str</code> <p>the Virtual Tools name of one of the target objects</p> required <code>obj2</code> <code>str</code> <p>the Virtual Tools name of the other target object</p> required <code>duration</code> <code>float</code> <p>the amount of time (in seconds) the objects must remain in contact</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def attach_specific_touch(self, obj1: str, obj2: str, duration: float):\n    \"\"\"Sets a victory condition in which two objects must come into contact\n\n    Args:\n        obj1 (str): the Virtual Tools name of one of the target objects\n        obj2 (str): the Virtual Tools name of the other target object\n        duration (float): the amount of time (in seconds) the objects must remain in contact\n    \"\"\"        \n    self.goal_cond = VTCond_SpecificTouch(obj1, obj2, duration, self)\n    self.goal_cond.attach_hooks()\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.check_circle_collision","title":"<code>check_circle_collision(pos, rad)</code>","text":"<p>Checks if there would be a colision with an object if a circular object were placed in the world</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>Tuple[float, float]</code> <p>the center of the hypothetical circular object</p> required <code>rad</code> <code>float</code> <p>the radius of the hypothetical circular object</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if there would be a colision, false if not</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def check_circle_collision(self, pos: Tuple[float, float], rad: float) -&gt; bool:\n    \"\"\"Checks if there would be a colision with an object if a circular object were placed in the world\n\n    Args:\n        pos (Tuple[float, float]): the center of the hypothetical circular object\n        rad (float): the radius of the hypothetical circular object\n\n    Returns:\n        bool: true if there would be a colision, false if not\n    \"\"\"        \n    tmpBody = pm.Body(1,1)\n    placeShape = pm.Circle(tmpBody, rad, pos)\n    placeShape.collision_type = COLTYPE_CHECKER\n    placeShape.sensor = True\n    self._cpSpace.step(.000001)\n\n    self.has_place_collision = False\n    squery = self._cpSpace.shape_query(placeShape)\n    return len(squery) &gt; 0\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.check_collision","title":"<code>check_collision(pos, verts)</code>","text":"<p>Checks whether placing a convex polygon in the world would cause a collision</p> <p>Parameters:</p> Name Type Description Default <code>pos</code> <code>Tuple[float, float]</code> <p>the position of the hypothetical polygon (where all vertices are calculated wrt)</p> required <code>verts</code> <code>List[Tuple[float, float]]</code> <p>a list of (x,y) vertices of the convex polygon, relative to the position</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if there would be a collision, false if not</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def check_collision(self, pos: Tuple[float, float], verts: List[Tuple[float, float]]) -&gt; bool:\n    \"\"\"Checks whether placing a convex polygon in the world would cause a collision\n\n    Args:\n        pos (Tuple[float, float]): the position of the hypothetical polygon (where all vertices are calculated wrt)\n        verts (List[Tuple[float, float]]): a list of (x,y) vertices of the convex polygon, relative to the position\n\n    Returns:\n        bool: true if there would be a collision, false if not\n    \"\"\"        \n    nvert = [(v[0]+pos[0], v[1]+pos[1]) for v in verts]\n    tmpBody = pm.Body(1,1)\n    placeShape = pm.Poly(tmpBody, nvert)\n    placeShape.collision_type = COLTYPE_CHECKER\n    placeShape.sensor = True\n    self._cpSpace.step(.000001)\n\n    self.has_place_collision = False\n    squery = self._cpSpace.shape_query(placeShape)\n    \"\"\" Code doesn't account for blockers (sensors)\n    # Update 12/12/23: I don't see why this wouldn't but if you're getting incorrect output, check the blockers!\n    if len(squery) == 0:\n        return False\n    else:\n        for sq in squery:\n            for p in sq.contact_point_set.points:\n                if p.distance &gt; 0:\n                    return True\n        return False\n    \"\"\"\n    return len(squery) &gt; 0\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.check_end","title":"<code>check_end()</code>","text":"<p>Returns whether the victory condition of the world has been cleared</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if victory is achieved; false if not (or if no condition exists)</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def check_end(self) -&gt; bool:\n    \"\"\"Returns whether the victory condition of the world has been cleared\n\n    Returns:\n        bool: true if victory is achieved; false if not (or if no condition exists)\n    \"\"\"        \n    if self.goal_cond is None:\n        return False\n    return self.goal_cond.is_won()\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.check_finishers","title":"<code>check_finishers()</code>","text":"<p>Makes sure there is a way to exit the world -- a victory condition and a win_callback that happens afterwards</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>true if goal_cond and win_callback exist, false otherwise</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def check_finishers(self) -&gt; bool:\n    \"\"\"Makes sure there is a way to exit the world -- a victory condition and a win_callback that happens afterwards\n\n    Returns:\n        bool: true if goal_cond and win_callback exist, false otherwise\n    \"\"\"        \n    return self.goal_cond is not None and self.win_callback is not None\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.distance_to_goal","title":"<code>distance_to_goal(point)</code>","text":"<p>Returns the distance between the nearest object achieving victory and the goal area / other object</p> <p>WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Tuple[float, float]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>description</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if no goal condition is specified</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def distance_to_goal(self, point: Tuple[float, float]) -&gt; float:\n    \"\"\"Returns the distance between the nearest object achieving victory and the goal area / other object\n\n    WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!\n\n    Args:\n        point (Tuple[float, float]): _description_\n\n    Returns:\n        float: _description_\n\n    Raises:\n        AssertionError: if no goal condition is specified\n    \"\"\"        \n    assert self.goal_cond, \"Goal condition must be specified to get distance\"\n    warnings.warn(\"This function is old and looks wrong - be careful using it\")\n    # Special case... requires getting two distances\n    if type(self.goal_cond) == VTCond_SpecificTouch:\n        o1 = self.get_object(self.goal_cond.o1)\n        o2 = self.get_object(self.goal_cond.o2)\n        #in this case, we actually want the distance between these two objects...\n        return np.abs(o1.distance_from_point([0,0]) - o2.distance_from_point([0,0])) #distance between these two objects is thing that matters\n    else:\n        gobj = self.get_object(self.goal_cond.goal)\n        return max(gobj.distance_from_point(point), 0)\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.distance_to_goal_container","title":"<code>distance_to_goal_container(point)</code>","text":"<p>Returns the distance between the nearest object achieving victory and the goal area / other object; specifies that for container objects, you want the distance to the top of the container</p> <p>WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Tuple[float, float]</code> <p>description</p> required <p>Returns:</p> Name Type Description <code>_type_</code> <p>description</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def distance_to_goal_container(self, point: Tuple[float, float]):\n    \"\"\"Returns the distance between the nearest object achieving victory and the goal area / other object; specifies that for container objects, you want the distance to the top of the container\n\n    WARNING: this seems like an old function and doesn't account for a number of VTCond types, plus the math looks off... so be careful!\n\n\n    Args:\n        point (Tuple[float, float]): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    assert self.goal_cond, \"Goal condition must be specified to get distance\"\n    warnings.warn(\"This function is old and looks wrong - be careful using it\")\n    try:\n        # Special case... requires getting two distances\n        if type(self.goal_cond) == VTCond_SpecificTouch:\n            o1 = self.get_object(self.goal_cond.o1)\n            o2 = self.get_object(self.goal_cond.o2)\n            #in this case, we actually want the distance between these two objects...\n            return np.abs(o1.distance_from_point([0,0]) - o2.distance_from_point([0,0])) #distance between these two objects is thing that matters\n        else:\n            gobj = self.get_object(self.goal_cond.goal)\n            if gobj.type != 'Container':\n                return gobj.distance_from_point(point)\n            else:\n                if self.distance_to_goal(point) == 0:\n                    return 0\n                else:\n                    return distance_to_object(gobj, point)\n    except:\n        pdb.set_trace()\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.get_dynamic_objects","title":"<code>get_dynamic_objects()</code>","text":"<p>Returns a list of all dynamic (not static) objects in the world</p> <p>Returns:</p> Type Description <code>List[VTObject]</code> <p>List[VTObject]: a List of all of the dynamics VTObjects</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def get_dynamic_objects(self) -&gt; List[VTObject]:\n    \"\"\"Returns a list of all dynamic (not static) objects in the world\n\n    Returns:\n        List[VTObject]: a List of all of the dynamics VTObjects\n    \"\"\"        \n    return [self.objects[i] for i in self.objects.keys() if not self.objects[i].is_static()]\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.get_gravity","title":"<code>get_gravity()</code>","text":"<p>Returns the gravity in units/s^2 downwards</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>gravity</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def get_gravity(self) -&gt; float:\n    \"\"\"Returns the gravity in units/s^2 downwards\n\n    Returns:\n        float: gravity\n    \"\"\"        \n    return -self._cpSpace.gravity.y\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.get_object","title":"<code>get_object(name)</code>","text":"<p>Returns an object that exists in the world</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the Virtual Tools name flag of the object</p> required <p>Returns:</p> Name Type Description <code>VTObject</code> <code>VTObject</code> <p>the object within the world</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>if the object doesn't exist</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def get_object(self, name: str) -&gt; VTObject:\n    \"\"\"Returns an object that exists in the world\n\n    Args:\n        name (str): the Virtual Tools name flag of the object\n\n    Returns:\n        VTObject: the object within the world\n\n    Raises:\n        AssertionError: if the object doesn't exist\n    \"\"\"        \n    assert name in self.objects.keys(), \"No object by that name: \" + name\n    return self.objects[name]\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.kick","title":"<code>kick(objectname, impulse, position)</code>","text":"<p>Applies an impulse to an object at a particular point</p> <p>Parameters:</p> Name Type Description Default <code>objectname</code> <code>str</code> <p>the Virtual Tools name of the object in this world</p> required <code>impulse</code> <code>Tuple[float, float]</code> <p>the impulse (momentum) vector</p> required <code>position</code> <code>Tuple[float, float]</code> <p>the point to apply the impulse to in world coordinates. Note: this must be inside the object!</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def kick(self, objectname: str, impulse: Tuple[float, float], position: Tuple[float, float]):\n    \"\"\"Applies an impulse to an object at a particular point\n\n    Args:\n        objectname (str): the Virtual Tools name of the object in this world\n        impulse (Tuple[float, float]): the impulse (momentum) vector\n        position (Tuple[float, float]): the point to apply the impulse to in world coordinates. Note: this must be inside the object!\n    \"\"\"        \n    o = self.get_object(objectname)\n    o.kick(impulse, position)\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.reset_collisions","title":"<code>reset_collisions()</code>","text":"<p>Clears out the collision events list</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def reset_collisions(self):\n    \"\"\"Clears out the collision events list\n    \"\"\"        \n    self._collision_events = []\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.set_gravity","title":"<code>set_gravity(val)</code>","text":"<p>Sets the gravity in units/s^2 downwards. Negative values make things fall \"up\"</p> <p>Parameters:</p> Name Type Description Default <code>val</code> <code>float</code> <p>gravity</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def set_gravity(self, val: float):\n    \"\"\"Sets the gravity in units/s^2 downwards. Negative values make things fall \"up\"\n\n    Args:\n        val (float): gravity\n    \"\"\"        \n    self._cpSpace.gravity = (0, -val)\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.step","title":"<code>step(t)</code>","text":"<p>Steps the world forward by t seconds. Not that this will not affect the precision of physics simulation; that is done via the <code>basic_timestep</code> value upon initialization</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>the amount of time (in seconds) to step forward</p> required Source code in <code>virtualtools/world/world.py</code> <pre><code>def step(self, t: float):\n    \"\"\"Steps the world forward by t seconds. Not that this will not affect the precision of physics simulation; that is done via the `basic_timestep` value upon initialization\n\n    Args:\n        t (float): the amount of time (in seconds) to step forward\n    \"\"\"        \n    nsteps = int(np.floor(t / self.bts))\n    remtime = self.bts % t\n    self.time += t\n    for i in range(nsteps):\n        self._cpSpace.step(self.bts)\n        if self.check_end() and self.win_callback is not None:\n            self.win_callback()\n    if remtime / self.bts &gt; .01:\n        self._cpSpace.step(remtime)\n    if self.check_end() and self.win_callback is not None:\n        self.win_callback()\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.VTWorld.to_dict","title":"<code>to_dict()</code>","text":"<p>Outputs a JSON-serializable Dict describing the world</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if invalid object or goal types exist in the world. In theory this should never happen</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>a JSON-serializable Dict</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"Outputs a JSON-serializable Dict describing the world\n\n    Raises:\n        Exception: if invalid object or goal types exist in the world. In theory this should never happen\n\n    Returns:\n        Dict: a JSON-serializable Dict\n    \"\"\"        \n    wdict = dict()\n    wdict['dims'] = tuple(self.dims)\n    wdict['bts'] = self.bts\n    wdict['gravity'] = self.gravity\n    wdict['defaults'] = dict(density=self.def_density, friction=self.def_friction,\n                             elasticity=self.def_elasticity, color=self.def_col, bk_color=self.bk_col)\n\n    wdict['objects'] = dict()\n    for nm, o in self.objects.items():\n        attrs = dict(type=o.type, color=list(o.color), density=o.density,\n                     friction=o.friction, elasticity=o.elasticity)\n        if o.type == 'Poly':\n            attrs['vertices'] = _listify(o.vertices)\n        elif o.type == 'Ball':\n            attrs['position'] = list(o.position)\n            attrs['radius'] = o.radius\n        elif o.type == 'Segment':\n            attrs['p1'], attrs['p2'] = _listify(o.points)\n            attrs['width'] = o.r * 2\n        elif o.type == 'Container':\n            attrs['points'] = _listify(o.vertices)\n            attrs['width'] = o.r * 2\n            attrs['innerColor'] = o.inner_color\n            attrs['outerColor'] = o.outer_color\n        elif o.type == 'Goal':\n            attrs['vertices'] = _listify(o.vertices)\n        elif o.type == 'Compound':\n            attrs['polys'] = _listify(o.polys)\n        else:\n            raise Exception('Invalid object type provided')\n        wdict['objects'][nm] = attrs\n\n    wdict['blocks'] = dict()\n    for nm, b in self.blockers.items():\n        attrs = {'color': list(b.color), 'vertices': _listify(b.vertices)}\n        wdict['blocks'][nm] = attrs\n\n    wdict['constraints'] = dict()\n\n    if self.goal_cond is None:\n        wdict['gcond'] = None\n    else:\n        gc = self.goal_cond\n        if gc.type == 'AnyInGoal':\n            wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': '-',\n                              'exclusions': gc.excl, 'duration': gc.dur}\n        elif gc.type == 'SpecificInGoal':\n            wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': gc.obj, 'duration': gc.dur}\n        elif gc.type == 'ManyInGoal':\n            wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'objlist': gc.objlist, 'duration': gc.dur}\n        elif gc.type == \"AnyTouch\":\n            wdict['gcond'] = {'type': gc.type, 'goal': gc.goal, 'obj': '-', 'duration': gc.dur}\n        elif gc.type == 'SpecificTouch':\n            wdict['gcond'] = {'type': gc.type, 'goal': gc.o1, 'obj': gc.o2, 'duration': gc.dur}\n        else:\n            raise Exception('Invalid goal condition type provided')\n\n    return wdict\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.load_vt_from_dict","title":"<code>load_vt_from_dict(d)</code>","text":"<p>Takes a serializable Dict describing the world, and turns it into a VTWorld object</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Dict</code> <p>a serializable vesion of the world (e.g., from VTWorld.to_dict())</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if invalid object or goal types are described in the Dict</p> <p>Returns:</p> Name Type Description <code>VTWorld</code> <code>VTWorld</code> <p>the world described in the Dict</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def load_vt_from_dict(d: Dict) -&gt; VTWorld:\n    \"\"\"Takes a serializable Dict describing the world, and turns it into a VTWorld object\n\n    Args:\n        d (Dict): a serializable vesion of the world (e.g., from VTWorld.to_dict())\n\n    Raises:\n        Exception: if invalid object or goal types are described in the Dict\n\n    Returns:\n        VTWorld: the world described in the Dict\n    \"\"\"    \n    d = deepcopy(d)\n    def_elast = float(d['defaults']['elasticity'])\n    def_fric = float(d['defaults']['friction'])\n\n    vtw = VTWorld(d['dims'], d['gravity'], [False, False, False, False], d['bts'],\n                  float(d['defaults']['density']), def_elast, def_fric,\n                  word_to_color(d['defaults']['bk_color']), word_to_color(d['defaults']['color']))\n\n    for nm, o in d['objects'].items():\n        elasticity = float(o.get('elasticity', def_elast))\n        friction = float(o.get('friction', def_fric))\n        density = float(o.get('density', d['defaults']['density']))\n\n        if o['type'] == 'Poly':\n            vtw.add_poly(nm, o['vertices'], word_to_color(o['color']), density, elasticity, friction)\n        elif o['type'] == 'Ball':\n            vtw.add_ball(nm, o['position'], o['radius'], word_to_color(o['color']), density, elasticity, friction)\n        elif o['type'] == 'Segment':\n            vtw.add_segment(nm, o['p1'], o['p2'], o['width'], word_to_color(o['color']), density, elasticity, friction)\n        elif o['type'] == 'Container':\n            if 'innerColor' not in o:\n                if 'color' in o:\n                    ic = word_to_color(o['color'])\n                else:\n                    ic = None\n            else:\n                ic = word_to_color(o['innerColor'])\n            if 'outerColor' not in o:\n                oc = DEFAULT_COLOR\n            else:\n                oc = word_to_color(o['outerColor'])\n            vtw.add_container(nm, o['points'], o['width'], ic, oc, density, elasticity, friction)\n        elif o['type'] == 'Goal':\n            vtw.add_poly_goal(nm, o['vertices'], word_to_color(o['color']))\n        elif o['type'] == 'Compound':\n            vtw.add_compound(nm, o['polys'], word_to_color(o['color']), density, elasticity, friction)\n        else:\n            raise Exception(\"Invalid object type given: \" + o['type'])\n\n    for nm, b in d['blocks'].items():\n        vtw.add_poly_block(nm, b['vertices'], word_to_color(b['color']))\n\n    if d['gcond'] is not None:\n        g = d['gcond']\n        if g['type'] == 'AnyInGoal':\n            excl = g.get('exclusions', [])\n            vtw.attach_any_in_goal(g['goal'], float(g['duration']), excl)\n        elif g['type'] == 'SpecificInGoal':\n            vtw.attach_specific_in_goal(g['goal'], g['obj'], float(g['duration']))\n        elif g['type'] == 'ManyInGoal':\n            vtw.attach_many_in_goal(g['goal'], g['objlist'], float(g['duration']))\n        elif g['type'] == 'AnyTouch':\n            vtw.attach_any_touch(g['goal'], float(g['duration']))\n        elif g['type'] == 'SpecificTouch':\n            vtw.attach_specific_touch(g['goal'], g['obj'], float(g['duration']))\n        else:\n            raise Exception(\"In valid goal condition type given\")\n\n    return vtw\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.resolve_arbiter","title":"<code>resolve_arbiter(arb)</code>","text":"<p>Returns the Virtual Tool names involved in a pymunk arbiter</p> <p>Parameters:</p> Name Type Description Default <code>arb</code> <code>Arbiter</code> <p>the pymunk arbiter to query</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple[str, str]: the two names of the objects involved</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def resolve_arbiter(arb: pm.Arbiter) -&gt; Tuple[str, str]:\n    \"\"\"Returns the Virtual Tool names involved in a pymunk arbiter\n\n    Args:\n        arb (pm.Arbiter): the pymunk arbiter to query\n\n    Returns:\n        Tuple[str, str]: the two names of the objects involved\n    \"\"\"    \n    shs = arb.shapes\n    o1, o2 = shs\n    return o1.name, o2.name\n</code></pre>"},{"location":"reference/virtualtools/world/world/#virtualtools.world.world.reverse_world","title":"<code>reverse_world(w)</code>","text":"<p>Flips a world around its x-axis</p> <p>Parameters:</p> Name Type Description Default <code>w</code> <code>VTWorld</code> <p>the world to flip</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if an object has an illegal type. In theory this should never happen</p> <p>Returns:</p> Name Type Description <code>VTWorld</code> <code>VTWorld</code> <p>the flipped world</p> Source code in <code>virtualtools/world/world.py</code> <pre><code>def reverse_world(w: VTWorld) -&gt; VTWorld:\n    \"\"\"Flips a world around its x-axis\n\n    Args:\n        w (VTWorld): the world to flip\n\n    Raises:\n        Exception: if an object has an illegal type. In theory this should never happen\n\n    Returns:\n        VTWorld: the flipped world\n    \"\"\"    \n    xdim = w.dims[0]\n    def rev_pt(p):\n        return (xdim - p[0], p[1])\n    # Easier to do this as a dict than modify the objects themselves\n    d = w.to_dict()\n    for nm, o in d['objects'].items():\n        if o['type'] == 'Poly' or o['type'] == 'Goal':\n            o['vertices'] = [rev_pt(p) for p in o['vertices']]\n            o['vertices'].reverse()\n        elif o['type'] == 'Ball':\n            o['position'] = rev_pt(o['position'])\n        elif o['type'] == 'Segment':\n            o['p1'] = rev_pt(o['p1'])\n            o['p2'] = rev_pt(o['p2'])\n        elif o['type'] == 'Container':\n            o['points'] = [rev_pt(p) for p in o['points']]\n            o['points'].reverse()\n        elif o['type'] == 'Compound':\n            for i, poly in enumerate(o['polys']):\n                o['polys'][i] = [rev_pt(p) for p in poly]\n                o['polys'][i].reverse()\n        else:\n            raise Exception(\"Invalid object type given: \" + o['type'])\n\n    for nm, b in d['blocks'].items():\n        b['vertices'] = [rev_pt(p) for p in b['vertices']]\n        b['vertices'].reverse()\n\n    return load_vt_from_dict(d)\n</code></pre>"}]}